* [[https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/][面试题 27.
二叉树的镜像]]
  :PROPERTIES:
  :CUSTOM_ID: 面试题-27.-二叉树的镜像
  :END:
** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:
请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

#+begin_example
       4
     /   \
    2     7
   / \   / \
  1   3 6   9
#+end_example

镜像输出：

#+begin_example
       4
     /   \
    7     2
   / \   / \
  9   6 3   1
#+end_example

*示例 1：*

#+begin_example
  输入：root = [4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
#+end_example

*限制：*

- =0 <= 节点个数 <= 1000=

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None

  class Solution:
      def mirrorTree(self, root: TreeNode) -> TreeNode:
          if root is None:
              return None
          root.left, root.right = root.right, root.left
          self.mirrorTree(root.left)
          self.mirrorTree(root.right)
          return root
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {
      public TreeNode mirrorTree(TreeNode root) {
          if (root == null) return null;
          TreeNode t = root.left;
          root.left = root.right;
          root.right = t;
          mirrorTree(root.left);
          mirrorTree(root.right);
          return root;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
  var mirrorTree = function (root) {
    if (!root) return null;
    [root.left, root.right] = [root.right, root.left];
    mirrorTree(root.left);
    mirrorTree(root.right);
    return root;
  };
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  /**
   * Definition for a binary tree node.
   * type TreeNode struct {
   *     Val int
   *     Left *TreeNode
   *     Right *TreeNode
   * }
   */
  func mirrorTree(root *TreeNode) *TreeNode {
      if root == nil {
          return root
      }
      root.Left, root.Right = root.Right, root.Left
      mirrorTree(root.Left)
      mirrorTree(root.Right)
      return root
  }
#+end_example

*** *C++*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_src cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */

  class Solution {
  public:
      TreeNode* mirrorTree(TreeNode* root) {
          // 后续遍历
          if (nullptr == root) {
              return nullptr;
          }

          mirrorTree(root->left);
          mirrorTree(root->right);
          std::swap(root->left, root->right);

          return root;
      }
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
