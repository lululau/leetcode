* [[https://leetcode-cn.com/problems/bracket-lcci][面试题 08.09. 括号]]
  :PROPERTIES:
  :CUSTOM_ID: 面试题-08.09.-括号
  :END:
[[./lcci/08.09.Bracket/README_EN.org][English Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明：解集不能包含重复的子集。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

例如，给出 n = 3，生成结果为：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  [
    "((()))",
    "(()())",
    "(())()",
    "()(())",
    "()()()"
  ]
  </pre>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

递归求解。其中，=left= 表示剩余的 =(=，=right= 表示剩余的 =)=。

- 当 =left= > =right= 时，说明 state 中 =(= 少于
  =)=，不是合法组合，直接剪枝；
- 当 =right= == 0 时，说明 state 组合完毕；
- 当 =left= > 0 时，此时可往 state 添加一个 =(=；
- 当 =right= > 0 时，此时可往 state 添加一个 =)=。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def generateParenthesis(self, n: int) -> List[str]:
          res = []
          def generate(state, left, right):
              # 剩余的`(`多于`)`
              if left > right:
                  return
              if right == 0:
                  res.append(state)
                  return
              if left > 0:
                  generate(state + '(', left - 1, right)
              if right > 0:
                  generate(state + ')', left, right - 1)
          generate('', n, n)
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      List<String> res;

      public List<String> generateParenthesis(int n) {
          res = new ArrayList<>();
          generate("", n, n);
          return res;
      }

      private void generate(String state, int left, int right) {
          if (left > right) {
              return;
          }
          if (right == 0) {
              res.add(state);
              return;
          }
          if (left > 0) {
              generate(state + "(", left - 1, right);
          }
          if (right > 0) {
              generate(state + ")", left, right - 1);
          }
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number} n
   * @return {string[]}
   */
   var generateParenthesis = function(n) {
      let res = [];
      dfs(n, 0, 0, '', res);
      return res;
  };

  function dfs(n, left, right, prev, res) {
      if (left == n && right == n) {
          res.push(prev);
          return;
      }
      if (left < n) {
          dfs(n, left + 1, right, prev + '(', res);
      }
      if (right < left) {
          dfs(n, left, right + 1, prev + ')', res);
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
