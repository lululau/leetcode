* [[https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci][面试题
03.04. 化栈为队]]
  :PROPERTIES:
  :CUSTOM_ID: 面试题-03.04.-化栈为队
  :END:
[[./lcci/03.04.Implement Queue using Stacks/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

实现一个MyQueue类，该类用两个栈来实现一个队列。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例：

#+begin_html
  <pre>MyQueue queue = new MyQueue();<br><br>queue.push(1);<br>queue.push(2);<br>queue.peek();  // 返回 1<br>queue.pop();   // 返回 1<br>queue.empty(); // 返回 false</pre>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明：

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top,
size 和 is empty 操作是合法的。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

你所使用的语言也许不支持栈。你可以使用 list 或者
deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek
操作）。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  </p>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

- 每次压入元素时，放入第 1 个栈中；
- 第 2 个栈不为空时，不能倒入元素；
- 第 2 个栈为空时，必须将第 1 个栈的所有元素按顺序倒入第 2 个栈中。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class MyQueue:

      def __init__(self):
          """
          Initialize your data structure here.
          """
          self._s1, self._s2 = [], []


      def push(self, x: int) -> None:
          """
          Push element x to the back of queue.
          """
          self._s1.append(x)


      def pop(self) -> int:
          """
          Removes the element from in front of queue and returns that element.
          """
          if len(self._s2) == 0:
              while self._s1:
                  self._s2.append(self._s1.pop())
          return self._s2.pop()


      def peek(self) -> int:
          """
          Get the front element.
          """
          if len(self._s2) == 0:
              while self._s1:
                  self._s2.append(self._s1.pop())
          return self._s2[-1]


      def empty(self) -> bool:
          """
          Returns whether the queue is empty.
          """
          return len(self._s1) + len(self._s2) == 0



  # Your MyQueue object will be instantiated and called as such:
  # obj = MyQueue()
  # obj.push(x)
  # param_2 = obj.pop()
  # param_3 = obj.peek()
  # param_4 = obj.empty()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class MyQueue {
      private Stack<Integer> s1;
      private Stack<Integer> s2;

      /** Initialize your data structure here. */
      public MyQueue() {
          s1 = new Stack<>();
          s2 = new Stack<>();
      }

      /** Push element x to the back of queue. */
      public void push(int x) {
          s1.push(x);
      }

      /** Removes the element from in front of queue and returns that element. */
      public int pop() {
          if (s2.empty()) {
              while (!s1.empty()) {
                  s2.push(s1.pop());
              }
          }
          return s2.pop();
      }

      /** Get the front element. */
      public int peek() {
          if (s2.empty()) {
              while (!s1.empty()) {
                  s2.push(s1.pop());
              }
          }
          return s2.peek();
      }

      /** Returns whether the queue is empty. */
      public boolean empty() {
          return s1.empty() && s2.empty();
      }
  }

  /**
   * Your MyQueue object will be instantiated and called as such:
   * MyQueue obj = new MyQueue();
   * obj.push(x);
   * int param_2 = obj.pop();
   * int param_3 = obj.peek();
   * boolean param_4 = obj.empty();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
