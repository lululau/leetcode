* [[https://leetcode-cn.com/problems/palindrome-linked-list-lcci][面试题
02.06. 回文链表]]
  :PROPERTIES:
  :CUSTOM_ID: 面试题-02.06.-回文链表
  :END:
[[./lcci/02.06.Palindrome Linked List/README_EN.org][English Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

编写一个函数，检查输入的链表是否是回文的。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入： </strong>1-&gt;2
  <strong>输出：</strong> false 
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入： </strong>1-&gt;2-&gt;2-&gt;1
  <strong>输出：</strong> true 
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

进阶： 你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

#+begin_html
  </p>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

先用快慢指针找到链表的中点，接着反转右半部分的链表。然后同时遍历前后两段链表，若前后两段链表节点对应的值不等，说明不是回文链表，否则说明是回文链表。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, val=0, next=None):
  #         self.val = val
  #         self.next = next
  class Solution:
      def isPalindrome(self, head: ListNode) -> bool:
          if head is None or head.next is None:
              return True
          slow, fast = head, head.next
          while fast and fast.next:
              slow, fast = slow.next, fast.next.next
          pre, cur = None, slow.next
          while cur:
              t = cur.next
              cur.next = pre
              pre, cur = cur, t
          while pre:
              if pre.val != head.val:
                  return False
              pre, head = pre.next, head.next
          return True
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode() {}
   *     ListNode(int val) { this.val = val; }
   *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
   * }
   */
  class Solution {
      public boolean isPalindrome(ListNode head) {
          if (head == null || head.next == null) {
              return true;
          }
          ListNode slow = head;
          ListNode fast = head.next;
          while (fast != null && fast.next != null) {
              slow = slow.next;
              fast = fast.next.next;
          }
          ListNode cur = slow.next;
          slow.next = null;
          ListNode pre = null;
          while (cur != null) {
              ListNode t = cur.next;
              cur.next = pre;
              pre = cur;
              cur = t;
          }
          while (pre != null) {
              if (pre.val != head.val) {
                  return false;
              }
              pre = pre.next;
              head = head.next;
          }
          return true;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * Definition for singly-linked list.
   * function ListNode(val, next) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.next = (next===undefined ? null : next)
   * }
   */
  /**
   * @param {ListNode} head
   * @return {boolean}
   */
  var isPalindrome = function(head) {
      if (!head || !head.next) {
          return true;
      }
      let slow = head;
      let fast = head.next;
      while (fast && fast.next) {
          slow = slow.next;
          fast = fast.next.next;
      }
      let cur = slow.next;
      slow.next = null;
      let pre = null;
      while (cur) {
          let t = cur.next;
          cur.next = pre;
          pre = cur;
          cur = t;
      }
      while (pre) {
          if (pre.val !== head.val) {
              return false;
          }
          pre = pre.next;
          head = head.next;
      }
      return true;
  };
#+end_src

*** *C#*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_example
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     public int val;
   *     public ListNode next;
   *     public ListNode(int val=0, ListNode next=null) {
   *         this.val = val;
   *         this.next = next;
   *     }
   * }
   */
  public class Solution {
      public bool IsPalindrome(ListNode head) {
          if (head == null || head.next == null)
          {
              return true;
          }
          ListNode slow = head;
          ListNode fast = head.next;
          while (fast != null && fast.next != null)
          {
              slow = slow.next;
              fast = fast.next.next;
          }
          ListNode cur = slow.next;
          slow.next = null;
          ListNode pre = null;
          while (cur != null)
          {
              ListNode t = cur.next;
              cur.next = pre;
              pre = cur;
              cur = t;
          }
          while (pre != null)
          {
              if (pre.val != head.val)
              {
                  return false;
              }
              pre = pre.next;
              head = head.next;
          }
          return true;
      }
  }
#+end_example

*** *TypeScript*
    :PROPERTIES:
    :CUSTOM_ID: typescript
    :END:
#+begin_example
  /**
   * Definition for singly-linked list.
   * class ListNode {
   *     val: number
   *     next: ListNode | null
   *     constructor(val?: number, next?: ListNode | null) {
   *         this.val = (val===undefined ? 0 : val)
   *         this.next = (next===undefined ? null : next)
   *     }
   * }
   */

  function isPalindrome(head: ListNode | null): boolean {
      if (head == null || head.next == null) return true;
      // 快慢指针定位到中点
      let slow: ListNode = head, fast: ListNode = head.next;
      while (fast != null && fast.next != null) {
          slow = slow.next;
          fast = fast.next.next;
      }
      // 翻转链表
      let cur: ListNode = slow.next;
      slow.next = null;
      let prev: ListNode = null;
      while (cur != null) {
          let t: ListNode = cur.next;
          cur.next = prev;
          prev = cur;
          cur = t;
      }
      // 判断回文
      while (prev != null) {
          if (prev.val != head.val) return false;
          prev = prev.next;
          head = head.next;
      }
      return true;
  };
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
