* [[https://leetcode.com/problems/delete-and-earn][740. Delete and
Earn]]
  :PROPERTIES:
  :CUSTOM_ID: delete-and-earn
  :END:
[[./solution/0700-0799/0740.Delete and Earn/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Given an array nums of integers, you can perform operations on the
array.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In each operation, you pick any nums[i] and delete it to earn nums[i]
points. After, you must delete every element equal to nums[i] - 1 or
nums[i] + 1.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You start with 0 points. Return the maximum number of points you can
earn by applying such operations.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> nums = [3,4,2]
  <strong>Output:</strong> 6
  <strong>Explanation:</strong> Delete 4 to earn 4 points, consequently 3 is also deleted.
  Then, delete 2 to earn 2 points.
  6 total points are earned.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> nums = [2,2,3,3,3,4]
  <strong>Output:</strong> 9
  <strong>Explanation:</strong> Delete 3 to earn 3 points, deleting both 2&#39;s and the 4.
  Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.
  9 total points are earned.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums.length <= 2 * 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums[i] <= 104

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

Intuition: *If we take a number, we will take all of the copies of it*.

First calculate the sum of each number as *sums*, and keep updating two
dp arrays: *select* and *nonSelect*

- sums[i] represents the sum of elements whose value is i;
- select[i] represents the maximum sum of processing from 0 to i if the
  number i is selected;
- nonSelect[i] represents the maximum sum of processing from 0 to i if
  the number i is not selected;

Then we have the following conclusions:

- If i is selected, then i-1 must not be selected;
- If you do not choose i, then i-1 can choose or not, so we choose the
  larger one;

#+begin_src java
  select[i] = nonSelect[i-1] + sums[i];
  nonSelect[i] = Math.max(select[i-1], nonSelect[i-1]);
#+end_src

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def deleteAndEarn(self, nums: List[int]) -> int:
          mx = float('-inf')
          for num in nums:
              mx = max(mx, num)
          total = [0] * (mx + 1)
          for num in nums:
              total[num] += num
          first = total[0]
          second = max(total[0], total[1])
          for i in range(2, mx + 1):
              cur = max(first + total[i], second)
              first = second
              second = cur
          return second
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public int deleteAndEarn(int[] nums) {
          if (nums.length == 0) {
              return 0;
          }

          int[] sums = new int[10010];
          int[] select = new int[10010];
          int[] nonSelect = new int[10010];

          int maxV = 0;
          for (int x : nums) {
              sums[x] += x;
              maxV = Math.max(maxV, x);
          }

          for (int i = 1; i <= maxV; i++) {
              select[i] = nonSelect[i - 1] + sums[i];
              nonSelect[i] = Math.max(select[i - 1], nonSelect[i - 1]);
          }
          return Math.max(select[maxV], nonSelect[maxV]);
      }
  }
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func deleteAndEarn(nums []int) int {

      max := func(x, y int) int {
          if x > y {
              return x
          }
          return y
      }

      mx := math.MinInt32
      for _, num := range nums {
          mx = max(mx, num)
      }
      total := make([]int, mx+1)
      for _, num := range nums {
          total[num] += num
      }
      first := total[0]
      second := max(total[0], total[1])
      for i := 2; i <= mx; i++ {
          cur := max(first+total[i], second)
          first = second
          second = cur
      }
      return second
  }
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
