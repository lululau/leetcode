* [[https://leetcode-cn.com/problems/next-greater-node-in-linked-list][1019.
链表中的下一个更大节点]]
  :PROPERTIES:
  :CUSTOM_ID: 链表中的下一个更大节点
  :END:
[[./solution/1000-1099/1019.Next Greater Node In Linked List/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1,
node_2, node_3, ... 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

每个节点都可能有下一个更大值（next larger
value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j
> i 且  node_j.val >
node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注意：在下面的示例中，诸如 [2,1,5]
这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为
1，第三个节点值为 5 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[2,1,5]
  <strong>输出：</strong>[5,5,0]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[2,7,4,3,5]
  <strong>输出：</strong>[7,0,5,5,0]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[1,7,5,1,9,2,5,1]
  <strong>输出：</strong>[7,9,9,9,0,5,0,0]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

对于链表中的每个节点，1 <= node.val <= 10^9

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

给定列表的长度在 [0, 10000] 范围内

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

"单调栈"实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.next = None

  class Solution:
      def nextLargerNodes(self, head: ListNode) -> List[int]:
          nums = []
          while head:
              nums.append(head.val)
              head = head.next
          s = []
          larger = [0] * len(nums)
          for i, num in enumerate(nums):
              while s and nums[s[-1]] < num:
                  larger[s.pop()] = num
              s.append(i)
          return larger
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) { val = x; }
   * }
   */
  class Solution {
      public int[] nextLargerNodes(ListNode head) {
          List<Integer> nums = new ArrayList<>();
          while (head != null) {
              nums.add(head.val);
              head = head.next;
          }
          Deque<Integer> s = new ArrayDeque<>();
          int[] larger = new int[nums.size()];
          for (int i = 0; i < nums.size(); ++i) {
              while (!s.isEmpty() && nums.get(s.peek()) < nums.get(i)) {
                  larger[s.pop()] = nums.get(i);
              }
              s.push(i);
          }
          return larger;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   *     this.val = val;
   *     this.next = null;
   * }
   */
  /**
   * @param {ListNode} head
   * @return {number[]}
   */
  var nextLargerNodes = function(head) {
      let nums = [];
      while (head != null) {
          nums.push(head.val);
          head = head.next;
      }
      const n = nums.length;
      let larger = new Array(n).fill(0);
      let stack = [];
      for (let i = 0; i < n; i++) {
          let num = nums[i];
          while (stack.length > 0 && nums[stack[stack.length - 1]] < num) {
              larger[stack.pop()] = num;
          }
          stack.push(i);
      }
      return larger;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
