* [[https://leetcode.com/problems/boundary-of-binary-tree][545. Boundary
of Binary Tree]]
  :PROPERTIES:
  :CUSTOM_ID: boundary-of-binary-tree
  :END:
[[./solution/0500-0599/0545.Boundary of Binary Tree/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

The boundary of a binary tree is the concatenation of the root, the left
boundary, the leaves ordered from left-to-right, and the reverse order
of the right boundary.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The left boundary is the set of nodes defined by the following:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The root node's left child is in the left boundary. If the root does not
have a left child, then the left boundary is empty.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

If a node in the left boundary and has a left child, then the left child
is in the left boundary.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

If a node is in the left boundary, has no left child, but has a right
child, then the right child is in the left boundary.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The leftmost leaf is not in the left boundary.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

The right boundary is similar to the left boundary, except it is the
right side of the root's right subtree. Again, the leaf is not part of
the right boundary, and the right boundary is empty if the root does not
have a right child.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The leaves are nodes that do not have any children. For this problem,
the root is not a leaf.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Given the root of a binary tree, return the values of its boundary.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,4]
  <strong>Output:</strong> [1,3,4,2]
  <b>Explanation:</b>
  - The left boundary is empty because the root does not have a left child.
  - The right boundary follows the path starting from the root&#39;s right child 2 -&gt; 4.
    4 is a leaf, so the right boundary is [2].
  - The leaves from left to right are [3,4].
  Concatenating everything results in [1] + [] + [3,4] + [2] = [1,3,4,2].
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,2,3,4,5,6,null,null,null,7,8,9,10]
  <strong>Output:</strong> [1,2,4,7,8,9,10,6,3]
  <b>Explanation:</b>
  - The left boundary follows the path starting from the root&#39;s left child 2 -&gt; 4.
    4 is a leaf, so the left boundary is [2].
  - The right boundary follows the path starting from the root&#39;s right child 3 -&gt; 6 -&gt; 10.
    10 is a leaf, so the right boundary is [3,6], and in reverse order is [6,3].
  - The leaves from left to right are [4,7,8,9,10].
  Concatenating everything results in [1] + [2] + [4,7,8,9,10] + [6,3] = [1,2,4,7,8,9,10,6,3].
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The number of nodes in the tree is in the range [1, 104].

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

-1000 <= Node.val <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def boundaryOfBinaryTree(self, root: TreeNode) -> List[int]:
          self.res = []
          if not root:
              return self.res
          # root
          if not self.is_leaf(root):
              self.res.append(root.val)

          # left boundary
          t = root.left
          while t:
              if not self.is_leaf(t):
                  self.res.append(t.val)
              t = t.left if t.left else t.right

          # leaves
          self.add_leaves(root)

          # right boundary(reverse order)
          s = []
          t = root.right
          while t:
              if not self.is_leaf(t):
                  s.append(t.val)
              t = t.right if t.right else t.left
          while s:
              self.res.append(s.pop())

          # output
          return self.res

      def add_leaves(self, root):
          if self.is_leaf(root):
              self.res.append(root.val)
              return
          if root.left:
              self.add_leaves(root.left)
          if root.right:
              self.add_leaves(root.right)

      def is_leaf(self, node) -> bool:
          return node and node.left is None and node.right is None
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      private List<Integer> res;

      public List<Integer> boundaryOfBinaryTree(TreeNode root) {
          if (root == null) {
              return Collections.emptyList();
          }
          res = new ArrayList<>();

          // root
          if (!isLeaf(root)) {
              res.add(root.val);
          }

          // left boundary
          TreeNode t = root.left;
          while (t != null) {
              if (!isLeaf(t)) {
                  res.add(t.val);
              }
              t = t.left == null ? t.right : t.left;
          }

          // leaves
          addLeaves(root);

          // right boundary(reverse order)
          Deque<Integer> s = new ArrayDeque<>();
          t = root.right;
          while (t != null) {
              if (!isLeaf(t)) {
                  s.offer(t.val);
              }
              t = t.right == null ? t.left : t.right;
          }
          while (!s.isEmpty()) {
              res.add(s.pollLast());
          }

          // output
          return res;
      }

      private void addLeaves(TreeNode root) {
          if (isLeaf(root)) {
              res.add(root.val);
              return;
          }
          if (root.left != null) {
              addLeaves(root.left);
          }
          if (root.right != null) {
              addLeaves(root.right);
          }
      }

      private boolean isLeaf(TreeNode node) {
          return node != null && node.left == null && node.right == null;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
