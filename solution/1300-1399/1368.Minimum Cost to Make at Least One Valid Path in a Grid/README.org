* [[https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid][1368.
使网格图至少有一条有效路径的最小代价]]
  :PROPERTIES:
  :CUSTOM_ID: 使网格图至少有一条有效路径的最小代价
  :END:
[[./solution/1300-1399/1368.Minimum Cost to Make at Least One Valid Path in a Grid/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个 m x n
的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m -
1, n - 1) 结束的路径。有效路径 不需要是最短路径 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

你可以花费 cost =
1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你返回让网格图至少有一条有效路径的最小代价。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
  <strong>输出：</strong>3
  <strong>解释：</strong>你将从点 (0, 0) 出发。
  到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3)
  总花费为 cost = 3.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>grid = [[1,1,3],[3,2,2],[1,1,4]]
  <strong>输出：</strong>0
  <strong>解释：</strong>不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>grid = [[1,2],[4,3]]
  <strong>输出：</strong>1
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>grid = [[2,2,2],[2,2,2]]
  <strong>输出：</strong>3
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 5：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>grid = [[4]]
  <strong>输出：</strong>0
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

m == grid.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n == grid[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m, n <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
