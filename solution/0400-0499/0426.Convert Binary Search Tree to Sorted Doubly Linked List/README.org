* [[https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list][426.
将二叉搜索树转化为排序的双向链表]]
  :PROPERTIES:
  :CUSTOM_ID: 将二叉搜索树转化为排序的双向链表
  :END:
[[./solution/0400-0499/0426.Convert Binary Search Tree to Sorted Doubly Linked List/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

将一个 二叉搜索树 就地转化为一个 已排序的双向循环链表 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

特别地，我们希望可以 就地
完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [4,2,5,1,3] 

  <img src="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0426.Convert Binary Search Tree to Sorted Doubly Linked List/images/bstdllreturndll.png" style="width: 400px;" />
  <strong>输出：</strong>[1,2,3,4,5]

  <strong>解释：</strong>下图显示了转化后的二叉搜索树，实线表示后继关系，虚线表示前驱关系。
  <img src="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/0400-0499/0426.Convert Binary Search Tree to Sorted Doubly Linked List/images/bstdllreturnbst.png" style="width: 400px;" />
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [2,1,3]
  <strong>输出：</strong>[1,2,3]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = []
  <strong>输出：</strong>[]
  <strong>解释：</strong>输入是空树，所以输出也是空链表。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [1]
  <strong>输出：</strong>[1]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

-1000 <= Node.val <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Node.left.val < Node.val < Node.right.val

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Node.val 的所有值都是独一无二的

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= Number of Nodes <= 2000

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

- 排序链表：二叉搜索树中序遍历得到有序序列
- 循环链表：头节点指向链表尾节点，尾节点指向链表头节点
- 双向链表：=pre.right = cur=、=cur.left = pre=、=pre = cur=

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  """
  # Definition for a Node.
  class Node:
      def __init__(self, val, left=None, right=None):
          self.val = val
          self.left = left
          self.right = right
  """
  class Solution:
      def treeToDoublyList(self, root: 'Node') -> 'Node':
          def dfs(cur):
              if cur is None:
                  return
              dfs(cur.left)
              if self.pre is None:
                  self.head = cur
              else:
                  self.pre.right = cur
              cur.left = self.pre
              self.pre = cur
              dfs(cur.right)
          if root is None:
              return None
          self.head = self.pre = None
          dfs(root)
          self.head.left = self.pre
          self.pre.right = self.head
          return self.head
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /*
  // Definition for a Node.
  class Node {
      public int val;
      public Node left;
      public Node right;

      public Node() {}

      public Node(int _val) {
          val = _val;
      }

      public Node(int _val,Node _left,Node _right) {
          val = _val;
          left = _left;
          right = _right;
      }
  };
  */

  class Solution {
      private Node head;
      private Node pre;

      public Node treeToDoublyList(Node root) {
          if (root == null) return null;
          dfs(root);
          head.left = pre;
          pre.right = head;
          return head;
      }

      private void dfs(Node cur) {
          if (cur == null) return;
          dfs(cur.left);
          if (pre == null) head = cur;
          else pre.right = cur;
          cur.left = pre;
          pre = cur;
          dfs(cur.right);
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * // Definition for a Node.
   * function Node(val,left,right) {
   *    this.val = val;
   *    this.left = left;
   *    this.right = right;
   * };
   */
  /**
   * @param {Node} root
   * @return {Node}
   */
  var treeToDoublyList = function (root) {
    function dfs(cur) {
      if (!cur) return;
      dfs(cur.left);
      if (!pre) head = cur;
      else pre.right = cur;
      cur.left = pre;
      pre = cur;
      dfs(cur.right);
    }
    if (!root) return null;
    let head, pre;
    dfs(root);
    head.left = pre;
    pre.right = head;
    return head;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
