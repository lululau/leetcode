* [[https://leetcode-cn.com/problems/circular-array-loop][457.
环形数组是否存在循环]]
  :PROPERTIES:
  :CUSTOM_ID: 环形数组是否存在循环
  :END:
[[./solution/0400-0499/0457.Circular Array Loop/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i
的角色应该向前或向后移动的下标个数：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

如果 nums[i] 是正数，向前 移动 nums[i] 步

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果 nums[i] 是负数，向后 移动 nums[i] 步

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

因为数组是 环形
的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

数组中的 循环 由长度为 k 的下标序列 seq ：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

遵循上述移动规则将导致重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1]
-> seq[0] -> ...

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

所有 nums[seq[j]] 应当不是 全正 就是 全负

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

k > 1

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

如果 nums 中存在循环，返回 true ；否则，返回 false 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums = [2,-1,1,2,2]
  <strong>输出：</strong>true
  <strong>解释：</strong>存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums = [-1,2]
  <strong>输出：</strong>false
  <strong>解释：</strong>按下标 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums = [-2,1,-1,-2,-2]
  <strong>输出：</strong>false
  <strong>解释：</strong>按下标 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。
  所有 nums[seq[j]] 应当不是全正就是全负。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums.length <= 5000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

-1000 <= nums[i] <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

nums[i] != 0

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

进阶：你能设计一个时间复杂度为 O(n) 且额外空间复杂度为 O(1) 的算法吗？

#+begin_html
  </p>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
