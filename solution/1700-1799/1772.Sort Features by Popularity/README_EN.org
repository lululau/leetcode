* [[https://leetcode.com/problems/sort-features-by-popularity][1772.
Sort Features by Popularity]]
  :PROPERTIES:
  :CUSTOM_ID: sort-features-by-popularity
  :END:
[[./solution/1700-1799/1772.Sort Features by Popularity/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given a string array features where features[i] is a single word
that represents the name of a feature of the latest product you are
working on. You have made a survey where users have reported which
features they like. You are given a string array responses, where each
responses[i] is a string containing space-separated words.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The popularity of a feature is the number of responses[i] that contain
the feature. You want to sort the features in non-increasing order by
their popularity. If two features have the same popularity, order them
by their original index in features. Notice that one response could
contain the same feature multiple times; this feature is only counted
once in its popularity.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return the features in sorted order.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> features = [&quot;cooler&quot;,&quot;lock&quot;,&quot;touch&quot;], responses = [&quot;i like cooler cooler&quot;,&quot;lock touch cool&quot;,&quot;locker like touch&quot;]
  <strong>Output:</strong> [&quot;touch&quot;,&quot;cooler&quot;,&quot;lock&quot;]
  <strong>Explanation:</strong> appearances(&quot;cooler&quot;) = 1, appearances(&quot;lock&quot;) = 1, appearances(&quot;touch&quot;) = 2. Since &quot;cooler&quot; and &quot;lock&quot; both had 1 appearance, &quot;cooler&quot; comes first because &quot;cooler&quot; came first in the features array.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> features = [&quot;a&quot;,&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;], responses = [&quot;a&quot;,&quot;a aa&quot;,&quot;a a a a a&quot;,&quot;b a&quot;]
  <strong>Output:</strong> [&quot;a&quot;,&quot;aa&quot;,&quot;b&quot;,&quot;c&quot;]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= features.length <= 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= features[i].length <= 10

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

features contains no duplicates.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

features[i] consists of lowercase letters.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= responses.length <= 102

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= responses[i].length <= 103

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

responses[i] consists of lowercase letters and spaces.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

responses[i] contains no two consecutive spaces.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

responses[i] has no leading or trailing spaces.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def sortFeatures(self, features: List[str], responses: List[str]) -> List[str]:
          feature_set = set(features)
          counter = collections.Counter()
          for resp in responses:
              for feat in set(resp.split(' ')):
                  if feat in feature_set:
                      counter[feat] += 1
          order = {feat: i for i, feat in enumerate(features)}
          return sorted(features, key=lambda feat: (-counter[feat], order[feat]))
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public String[] sortFeatures(String[] features, String[] responses) {
          Set<String> featureSet = new HashSet<>();
          Map<String, Integer> order = new HashMap<>();
          for (int i = 0; i < features.length; ++i) {
              featureSet.add(features[i]);
              order.put(features[i], i);
          }

          Map<String, Integer> counter = new HashMap<>();
          for (String resp : responses) {
              Set<String> s = new HashSet<>();
              String[] words = resp.split(" ");
              for (String word : words) {
                  s.add(word);
              }
              for (String word : s) {
                  if (featureSet.contains(word)) {
                      counter.put(word, counter.getOrDefault(word, 0) + 1);
                  }
              }
          }
          String[] copyFeatures = Arrays.copyOf(features, features.length);
          Arrays.sort(copyFeatures, (a, b) -> {
              int diff = counter.getOrDefault(b, 0) - counter.getOrDefault(a, 0);
              return diff == 0 ? order.get(a) - order.get(b) : diff;
          });
          return copyFeatures;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
