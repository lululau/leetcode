* [[https://leetcode.com/problems/tree-of-coprimes][1766. Tree of
Coprimes]]
  :PROPERTIES:
  :CUSTOM_ID: tree-of-coprimes
  :END:
[[./solution/1700-1799/1766.Tree of Coprimes/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

There is a tree (i.e., a connected, undirected graph that has no cycles)
consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges.
Each node has a value associated with it, and the root of the tree is
node 0.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

To represent this tree, you are given an integer array nums and a 2D
array edges. Each nums[i] represents the ith node's value, and each
edges[j] = [uj, vj] represents an edge between nodes uj and vj in the
tree.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the
greatest common divisor of x and y.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

An ancestor of a node i is any other node on the shortest path from node
i to the root. A node is not considered an ancestor of itself.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return an array ans of size n, where ans[i] is the closest ancestor to
node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is
no such ancestor.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]
  <strong>Output:</strong> [-1,0,0,1]
  <strong>Explanation:</strong> In the above figure, each node&#39;s value is in parentheses.
  - Node 0 has no coprime ancestors.
  - Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1).
  - Node 2 has two ancestors, nodes 1 and 0. Node 1&#39;s value is not coprime (gcd(3,3) == 3), but node 0&#39;s
    value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor.
  - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its
    closest valid ancestor.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]
  <strong>Output:</strong> [-1,0,-1,0,0,0,-1]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

nums.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums[i] <= 50

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges.length == n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges[j].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= uj, vj < n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

uj != vj

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
