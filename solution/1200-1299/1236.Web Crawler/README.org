* [[https://leetcode-cn.com/problems/web-crawler][1236. 网络爬虫]]
  :PROPERTIES:
  :CUSTOM_ID: 网络爬虫
  :END:
[[./solution/1200-1299/1236.Web Crawler/README_EN.org][English Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定一个链接 startUrl
和一个接口 HtmlParser ，请你实现一个网络爬虫，以实现爬取同 startUrl 拥有相同 域名标签 的全部链接。该爬虫得到的全部链接可以 任何顺序 返回结果。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

你的网络爬虫应当按照如下模式工作：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

自链接 startUrl 开始爬取

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

调用 HtmlParser.getUrls(url) 来获得链接url页面中的全部链接

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

同一个链接最多只爬取一次

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

只输出 域名 与 startUrl 相同 的链接集合

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

如上所示的一个链接，其域名为 example.org。简单起见，你可以假设所有的链接都采用 http协议 并没有指定 端口。例如，链接 http://leetcode.com/problems 和 http://leetcode.com/contest 是同一个域名下的，而链接http://example.org/test 和 http://example.com/abc
是不在同一域名下的。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

HtmlParser 接口定义如下： 

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>interface HtmlParser {
    // 返回给定 url 对应的页面中的全部 url 。
    public List&lt;String&gt; getUrls(String url);
  }</pre>
#+end_html

#+begin_html
  <p>
#+end_html

下面是两个实例，用以解释该问题的设计功能，对于自定义测试，你可以使用三个变量  urls, edges 和 startUrl。注意在代码实现中，你只可以访问 startUrl ，而 urls 和 edges 不可以在你的代码中被直接访问。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：
  </strong>urls = [
  &nbsp; &quot;http://news.yahoo.com&quot;,
  &nbsp; &quot;http://news.yahoo.com/news&quot;,
  &nbsp; &quot;http://news.yahoo.com/news/topics/&quot;,
  &nbsp; &quot;http://news.google.com&quot;,
  &nbsp; &quot;http://news.yahoo.com/us&quot;
  ]
  edges = [[2,0],[2,1],[3,2],[3,1],[0,4]]
  startUrl = &quot;http://news.yahoo.com/news/topics/&quot;
  <strong>输出：</strong>[
  &nbsp; &quot;http://news.yahoo.com&quot;,
  &nbsp; &quot;http://news.yahoo.com/news&quot;,
  &nbsp; &quot;http://news.yahoo.com/news/topics/&quot;,
  &nbsp; &quot;http://news.yahoo.com/us&quot;
  ]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>
  urls = [
  &nbsp; &quot;http://news.yahoo.com&quot;,
  &nbsp; &quot;http://news.yahoo.com/news&quot;,
  &nbsp; &quot;http://news.yahoo.com/news/topics/&quot;,
  &nbsp; &quot;http://news.google.com&quot;
  ]
  edges = [[0,2],[2,1],[3,2],[3,1],[3,0]]
  startUrl = &quot;http://news.google.com&quot;
  <strong>输入：</strong>[&quot;http://news.google.com&quot;]
  <strong>解释：</strong>startUrl 链接到所有其他不共享相同主机名的页面。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= urls.length <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= urls[i].length <= 300

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

startUrl 为 urls 中的一个。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

域名标签的长为1到63个字符（包括点），只能包含从‘a'到‘z'的ASCII字母、‘0'到‘9'的数字以及连字符即减号（‘-'）。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

域名标签不会以连字符即减号（‘-'）开头或结尾。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

关于域名有效性的约束可参考:  https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_hostnames

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

你可以假定url库中不包含重复项。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
