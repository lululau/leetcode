* [[https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies][1203.
项目管理]]
  :PROPERTIES:
  :CUSTOM_ID: 项目管理
  :END:
[[./solution/1200-1299/1203.Sort Items by Groups Respecting Dependencies/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

有 n 个项目，每个项目或者不属于任何小组，或者属于 m 个小组之一。group[i]
表示第 i 个项目所属的小组，如果第 i 个项目不属于任何小组，则 group[i]
等于
-1。项目和小组都是从零开始编号的。可能存在小组不负责任何项目，即没有任何项目属于这个小组。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

同一小组的项目，排序后在列表中彼此相邻。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

项目之间存在一定的依赖关系，我们用一个列表
beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第
i 个项目左侧）应该完成的所有项目。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

如果存在多个解决方案，只需要返回其中任意一个即可。如果没有合适的解决方案，就请返回一个
空列表 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]
  <strong>输出：</strong>[6,3,4,1,5,2,0,7]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]
  <strong>输出：</strong>[]
  <strong>解释：</strong>与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m <= n <= 3 * 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

group.length == beforeItems.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

-1 <= group[i] <= m - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= beforeItems[i].length <= n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= beforeItems[i][j] <= n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

i != beforeItems[i][j]

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

beforeItems[i] 不含重复元素

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
