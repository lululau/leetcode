* [[https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal][971.
Flip Binary Tree To Match Preorder Traversal]]
  :PROPERTIES:
  :CUSTOM_ID: flip-binary-tree-to-match-preorder-traversal
  :END:
[[./solution/0900-0999/0971.Flip Binary Tree To Match Preorder Traversal/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given the root of a binary tree with n nodes, where each node is
uniquely assigned a value from 1 to n. You are also given a sequence of
n values voyage, which is the desired pre-order traversal of the binary
tree.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Any node in the binary tree can be flipped by swapping its left and
right subtrees. For example, flipping node 1 will have the following
effect:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Flip the smallest number of nodes so that the pre-order traversal of the
tree matches voyage.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return a list of the values of all flipped nodes. You may return the
answer in any order. If it is impossible to flip the nodes in the tree
to make the pre-order traversal match voyage, return the list [-1].

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,2], voyage = [2,1]
  <strong>Output:</strong> [-1]
  <strong>Explanation:</strong> It is impossible to flip the nodes such that the pre-order traversal matches voyage.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,2,3], voyage = [1,3,2]
  <strong>Output:</strong> [1]
  <strong>Explanation:</strong> Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.</pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,2,3], voyage = [1,2,3]
  <strong>Output:</strong> []
  <strong>Explanation:</strong> The tree&#39;s pre-order traversal already matches voyage, so no nodes need to be flipped.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The number of nodes in the tree is n.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n == voyage.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= Node.val, voyage[i] <= n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

All the values in the tree are unique.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

All the values in voyage are unique.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
