* [[https://leetcode-cn.com/problems/fruit-into-baskets][904. 水果成篮]]
  :PROPERTIES:
  :CUSTOM_ID: 水果成篮
  :END:
[[./solution/0900-0999/0904.Fruit Into Baskets/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

移动到当前树右侧的下一棵树。如果右边没有树，就停下来。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤
2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

用这个程序你能收集的水果树的最大总量是多少？

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[1,2,1]
  <strong>输出：</strong>3
  <strong>解释：</strong>我们可以收集 [1,2,1]。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[0,1,2,2]
  <strong>输出：</strong>3
  <strong>解释：</strong>我们可以收集 [1,2,2]
  如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[1,2,3,2,2]
  <strong>输出：</strong>4
  <strong>解释：</strong>我们可以收集 [2,3,2,2]
  如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>[3,3,3,1,2,1,1,2,3,3,4]
  <strong>输出：</strong>5
  <strong>解释：</strong>我们可以收集 [1,2,1,1,2]
  如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= tree.length <= 40000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= tree[i] < tree.length

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

"计数器 + 滑动窗口"实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def totalFruit(self, tree: List[int]) -> int:
          counter = collections.Counter()
          i = res = 0
          for j, type in enumerate(tree):
              counter[type] += 1
              while len(counter) > 2:
                  counter[tree[i]] -= 1
                  if counter[tree[i]] == 0:
                      counter.pop(tree[i])
                  i += 1
              res = max(res, j - i + 1)
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int totalFruit(int[] tree) {
          Map<Integer, Integer> counter = new HashMap<>();
          int i = 0, res = 0;
          for (int j = 0; j < tree.length; ++j) {
              counter.put(tree[j], counter.getOrDefault(tree[j], 0) + 1);
              while (counter.size() > 2) {
                  counter.put(tree[i], counter.get(tree[i]) - 1);
                  if (counter.get(tree[i]) == 0) {
                      counter.remove(tree[i]);
                  }
                  ++i;
              }
              res = Math.max(res, j - i + 1);
          }
          return res;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
