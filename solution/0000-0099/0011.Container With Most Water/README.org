* [[https://leetcode-cn.com/problems/container-with-most-water][11.
盛最多水的容器]]
  :PROPERTIES:
  :CUSTOM_ID: 盛最多水的容器
  :END:
[[./solution/0000-0099/0011.Container With Most Water/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai)
。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)
。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明：你不能倾斜容器。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>[1,8,6,2,5,4,8,3,7]
  <strong>输出：</strong>49 
  <strong>解释：</strong>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>height = [1,1]
  <strong>输出：</strong>1
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>height = [4,3,2,1,4]
  <strong>输出：</strong>16
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>height = [1,2,1]
  <strong>输出：</strong>2
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

n = height.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 3 * 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= height[i] <= 3 * 104

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

双指针解决。

一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离，而水的高度取决于两根柱子之间较短的那个。

- 当前柱子是最两侧的柱子，水的宽度最大，其他的组合，水的宽度都比这个小；
- 当前左侧柱子较短，决定了水的高度。如果移动左侧的柱子，新的水面高度不确定，但一定不会超过右侧的柱子高度；
- 如果移动右侧的柱子，新的水面高度一定不会超过左侧的柱子高度，也就是不会超过当前的水面高度。

可见，如果固定左侧的柱子，向内移动右侧的柱子，水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。所以左侧的柱子跟右侧其他柱子的组合，都可以排除了。也就是代码中的
=i++=。

移动左侧的柱子中，重复进行上面的操作。

在此过程中，我们不断排除掉无法成为构成最大值的柱子组合，而每一次都获取到可能为最大值的面积
t。那么遍历结束之后，我们就可以得到最大值。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def maxArea(self, height: List[int]) -> int:
          i, j = 0, len(height) - 1
          res = 0
          while i < j:
              t = (j - i) * min(height[i], height[j])
              res = max(res, t)
              if height[i] < height[j]:
                  i += 1
              else:
                  j -= 1
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int maxArea(int[] height) {
          int i = 0, j = height.length - 1;
          int res = 0;
          while (i < j) {
              int t = (j - i) * Math.min(height[i], height[j]);
              res = Math.max(res, t);
              if (height[i] < height[j]) ++i;
              else --j;
          }
          return res;
      }
  }
#+end_src

*** *C++*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_src cpp
  class Solution {
  public:
      int maxArea(vector<int>& height) {
          int i = 0, j = height.size() - 1;
          int res = 0;
          while (i < j) {
              int t = (j - i) * min(height[i], height[j]);
              res = max(res, t);
              if (height[i] < height[j]) ++i;
              else --j;
          }
          return res;
      }
  };
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func maxArea(height []int) int {
      i, j := 0, len(height) - 1
      res := 0
      for i != j {
          t := (j - i) * min(height[i], height[j])
          res = max(res, t)
          if height[i] < height[j] {
              i++
          } else {
              j--
          }
      }
      return res
  }

  func min(a, b int) int {
      if a > b {
          return b
      }
      return a
  }

  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
#+end_example

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number[]} height
   * @return {number}
   */
  var maxArea = function (height) {
    let i = 0,
      j = height.length - 1;
    let res = 0;
    while (i < j) {
      const t = (j - i) * Math.min(height[i], height[j]);
      res = Math.max(res, t);
      if (height[i] < height[j]) ++i;
      else --j;
    }
    return res;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
