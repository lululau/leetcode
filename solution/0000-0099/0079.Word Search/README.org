* [[https://leetcode-cn.com/problems/word-search][79. 单词搜索]]
  :PROPERTIES:
  :CUSTOM_ID: 单词搜索
  :END:
[[./solution/0000-0099/0079.Word Search/README_EN.org][English Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word
存在于网格中，返回 true ；否则，返回 false 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
  <strong>输出：</strong>true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
  <strong>输出：</strong>true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
  <strong>输出：</strong>false
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

m == board.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n = board[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m, n <= 6

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= word.length <= 15

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

board 和 word 仅由大小写英文字母组成

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

进阶：你可以使用搜索剪枝的技术来优化解决方案，使其在 board
更大的情况下可以更快解决问题？

#+begin_html
  </p>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

深度优先搜索 DFS 实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def exist(self, board: List[List[str]], word: str) -> bool:
          def dfs(i, j, cur):
              if cur == len(word):
                  return True
              if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or word[cur] != board[i][j]:
                  return False
              visited[i][j] = True
              next = cur + 1
              res = dfs(i + 1, j, next) or dfs(i - 1, j, next) or dfs(i, j + 1, next) or dfs(i, j - 1, next)
              visited[i][j] = False
              return res
          m, n = len(board), len(board[0])
          visited = [[False for _ in range(n)] for _ in range(m)]
          for i in range(m):
              for j in range(n):
                  res = dfs(i, j, 0)
                  if res:
                      return True
          return False
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      private boolean[][] visited;

      public boolean exist(char[][] board, String word) {
          int m = board.length, n = board[0].length;
          visited = new boolean[m][n];
          char[] chars = word.toCharArray();
          for (int i = 0; i < m; ++i) {
              for (int j = 0; j < n; ++j) {
                  boolean res = dfs(board, i, j, chars, 0);
                  if (res) return true;
              }
          }
          return false;
      }

      private boolean dfs(char[][] board, int i, int j, char[] chars, int cur) {
          if (cur == chars.length) return true;
          if (i < 0 || i >= board.length || j < 0 || j >= board[0].length) return false;
          if (visited[i][j] || board[i][j] != chars[cur]) return false;
          visited[i][j] = true;
          int next = cur + 1;
          boolean res = dfs(board, i + 1, j, chars, next)
                  || dfs(board, i - 1, j, chars, next)
                  || dfs(board, i, j + 1, chars, next)
                  || dfs(board, i, j - 1, chars, next);
          visited[i][j] = false;
          return res;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
