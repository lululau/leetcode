* [[https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals][1863.
找出所有子集的异或总和再求和]]
  :PROPERTIES:
  :CUSTOM_ID: 找出所有子集的异或总和再求和
  :END:
[[./solution/1800-1899/1863.Sum of All Subset XOR Totals/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空
，则异或总和为 0 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和
，计算并返回这些值相加之 和 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注意：在本题中，元素 相同 的不同子集应 多次 计数。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

数组 a 是数组 b 的一个 子集 的前提条件是：从 b
删除几个（也可能不删除）元素能够得到 a 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>nums = [1,3]
  <strong>输出：</strong>6
  <strong>解释：</strong>[1,3] 共有 4 个子集：
  - 空子集的异或总和是 0 。
  - [1] 的异或总和为 1 。
  - [3] 的异或总和为 3 。
  - [1,3] 的异或总和为 1 XOR 3 = 2 。
  0 + 1 + 3 + 2 = 6
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>nums = [5,1,6]
  <strong>输出：</strong>28
  <strong>解释：</strong>[5,1,6] 共有 8 个子集：
  - 空子集的异或总和是 0 。
  - [5] 的异或总和为 5 。
  - [1] 的异或总和为 1 。
  - [6] 的异或总和为 6 。
  - [5,1] 的异或总和为 5 XOR 1 = 4 。
  - [5,6] 的异或总和为 5 XOR 6 = 3 。
  - [1,6] 的异或总和为 1 XOR 6 = 7 。
  - [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。
  0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>nums = [3,4,5,6,7,8]
  <strong>输出：</strong>480
  <strong>解释：</strong>每个子集的全部异或总和值之和为 480 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums.length <= 12

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums[i] <= 20

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def subsetXORSum(self, nums: List[int]) -> int:
          def dfs(nums, depth, prev):
              self.res += prev
              for num in nums[depth:]:
                  prev ^= num
                  depth += 1
                  dfs(nums, depth, prev)
                  prev ^= num

          self.res = 0
          dfs(nums, 0, 0)
          return self.res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      private int res;

      public int subsetXORSum(int[] nums) {
          dfs(nums, 0, 0);
          return res;
      }

      private void dfs(int[] nums, int depth, int prev) {
          res += prev;
          for (int i = depth; i < nums.length; ++i) {
              prev ^= nums[i];
              dfs(nums, ++depth, prev);
              prev ^= nums[i];
          }
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number[]} nums
   * @return {number}
   */
   var subsetXORSum = function(nums) {
      let res = [];
      let prev = 0;
      dfs(nums, 0, prev, res);
      return res.reduce((a, c) => a + c, 0)
  };

  function dfs(nums, depth, prev, res) {
      res.push(prev);
      for (let i = depth; i < nums.length; i++) {
          prev ^= nums[i];
          depth++;
          dfs(nums, depth, prev, res);
          // bracktrack
          prev ^= nums[i];
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
