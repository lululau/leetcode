* [[https://leetcode.com/problems/process-tasks-using-servers][1882.
Process Tasks Using Servers]]
  :PROPERTIES:
  :CUSTOM_ID: process-tasks-using-servers
  :END:
[[./solution/1800-1899/1882.Process Tasks Using Servers/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given two 0-indexed integer arrays servers and tasks of lengths
n​​​​​​ and m​​​​​​ respectively. servers[i] is the weight of the
i​​​​​​th​​​​ server, and tasks[j] is the time needed to process the
j​​​​​​th​​​​ task in seconds.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You are running a simulation system that will shut down after all tasks
are processed. Each server can only process one task at a time. You will
be able to process the jth task starting from the jth second beginning
with the 0th task at second 0. To process task j, you assign it to the
server with the smallest weight that is free, and in case of a tie,
choose the server with the smallest index. If a free server gets
assigned task j at second t,​​​​​​ it will be free again at the second t
+ tasks[j].

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

If there are no free servers, you must wait until one is free and
execute the free tasks as soon as possible. If multiple tasks need to be
assigned, assign them in order of increasing index.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You may assign multiple tasks at the same second if there are multiple
free servers.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Build an array ans​​​​ of length m, where ans[j] is the index of the
server the j​​​​​​th task will be assigned to.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return the array ans​​​​.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> servers = [3,3,2], tasks = [1,2,3,2,1,2]
  <strong>Output:</strong> [2,2,0,2,1,2]
  <strong>Explanation: </strong>Events in chronological order go as follows:
  - At second 0, task 0 is added and processed using server 2 until second 1.
  - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.
  - At second 2, task 2 is added and processed using server 0 until second 5.
  - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.
  - At second 4, task 4 is added and processed using server 1 until second 5.
  - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.</pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1]
  <strong>Output:</strong> [1,4,1,4,1,3,2]
  <strong>Explanation: </strong>Events in chronological order go as follows: 
  - At second 0, task 0 is added and processed using server 1 until second 2.
  - At second 1, task 1 is added and processed using server 4 until second 2.
  - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. 
  - At second 3, task 3 is added and processed using server 4 until second 7.
  - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. 
  - At second 5, task 5 is added and processed using server 3 until second 7.
  - At second 6, task 6 is added and processed using server 2 until second 7.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

servers.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

tasks.length == m

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n, m <= 2 * 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= servers[i], tasks[j] <= 2 * 105

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:
          idle, busy = [], []
          for i, weight in enumerate(servers):
              heapq.heappush(idle, (weight, i))
          res = []
          for start, cost in enumerate(tasks):
              while busy and busy[0][0] <= start:
                  _, s, i = heapq.heappop(busy)
                  heapq.heappush(idle, (s, i))
              if idle:
                  s, i = heapq.heappop(idle)
                  heapq.heappush(busy, (start + cost, s, i))
              else:
                  t, s, i = heapq.heappop(busy)
                  heapq.heappush(busy, (t + cost, s, i))
              res.append(i)
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public int[] assignTasks(int[] servers, int[] tasks) {
          int m = tasks.length, n = servers.length;
          PriorityQueue<int[]> idle = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
          PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> {
              if (a[0] == b[0]) {
                  return a[1] == b[1] ? a[2] - b[2] : a[1] - b[1];
              }
              return a[0] - b[0];
          });
          for (int i = 0; i < n; ++i) {
              idle.offer(new int[]{servers[i], i});
          }
          int[] res = new int[m];
          int j = 0;
          for (int start = 0; start < m; ++start) {
              int cost = tasks[start];
              while (!busy.isEmpty() && busy.peek()[0] <= start) {
                  int[] item = busy.poll();
                  idle.offer(new int[]{item[1], item[2]});
              }
              if (!idle.isEmpty()) {
                  int[] item = idle.poll();
                  res[j++] = item[1];
                  busy.offer(new int[]{start + cost, item[0], item[1]});
              } else {
                  int[] item = busy.poll();
                  res[j++] = item[2];
                  busy.offer(new int[]{item[0] + cost, item[1], item[2]});
              }
          }
          return res;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
