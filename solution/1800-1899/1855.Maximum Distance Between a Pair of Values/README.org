* [[https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values][1855.
下标对中的最大距离]]
  :PROPERTIES:
  :CUSTOM_ID: 下标对中的最大距离
  :END:
[[./solution/1800-1899/1855.Maximum Distance Between a Pair of Values/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你两个 非递增 的整数数组 nums1​​​​​​ 和 nums2​​​​​​ ，数组下标均 从 0
开始 计数。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

下标对 (i, j) 中 0 <= i < nums1.length 且 0 <= j < nums2.length
。如果该下标对同时满足 i <= j 且 nums1[i] <= nums2[j] ，则称之为 有效
下标对，该下标对的 距离 为 j - i​​ 。​​

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

返回所有 有效 下标对 (i, j) 中的 最大距离 。如果不存在有效下标对，返回 0
。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

一个数组 arr ，如果每个 1 <= i < arr.length 均有 arr[i-1] >= arr[i]
成立，那么该数组是一个 非递增 数组。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
  <strong>输出：</strong>2
  <strong>解释：</strong>有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。
  最大距离是 2 ，对应下标对 (2,4) 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums1 = [2,2,2], nums2 = [10,10,1]
  <strong>输出：</strong>1
  <strong>解释：</strong>有效下标对是 (0,0), (0,1) 和 (1,1) 。
  最大距离是 1 ，对应下标对 (0,1) 。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]
  <strong>输出：</strong>2
  <strong>解释：</strong>有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。
  最大距离是 2 ，对应下标对 (2,4) 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>nums1 = [5,4], nums2 = [3,2]
  <strong>输出：</strong>0
  <strong>解释：</strong>不存在有效下标对，所以返回 0 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums1.length <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums2.length <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= nums1[i], nums2[j] <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

nums1 和 nums2 都是 非递增 数组

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

二分法。

遍历数组 A，对于每个数字 =A[i]=，用二分法找到数组 B 中下标最大并且比
=A[i]= 还大的数字即可。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:
          res = 0
          for i in range(len(nums1)):
              l, r = i, len(nums2) - 1
              while l <= r:
                  mid = (l + r) >> 1
                  if nums2[mid] >= nums1[i]:
                      res = max(res, mid - i)
                      l = mid + 1
                  else:
                      r = mid - 1
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int maxDistance(int[] nums1, int[] nums2) {
          int res = 0;
          for (int i = 0; i < nums1.length; ++i) {
              int l = i, r = nums2.length - 1;
              while (l <= r) {
                  int mid = (l + r) >>> 1;
                  if (nums2[mid] >= nums1[i]) {
                      res = Math.max(res, mid - i);
                      l = mid + 1;
                  } else {
                      r = mid - 1;
                  }
              }
          }
          return res;
      }
  }
#+end_src

*** *C++*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_src cpp
  class Solution {
  public:
      int maxDistance(vector<int>& nums1, vector<int>& nums2) {
          int res = 0;
          for (int i = 0; i < nums1.size(); ++i) {
              int l = i, r = nums2.size() - 1;
              while (l <= r) {
                  int mid = (l + r) >> 1;
                  if (nums2[mid] >= nums1[i]) {
                      res = max(res, mid - i);
                      l = mid + 1;
                  } else {
                      r = mid - 1;
                  }
              }
          }
          return res;
      }
  };
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number}
   */
  var maxDistance = function(nums1, nums2) {
      let res = 0;
      for (let i = 0; i < nums1.length; i++) {
          let left = 0, right = nums2.length - 1;
          while (left <= right) {
              mid = (left + right) >> 1;
              if (nums2[mid] >= nums1[i]) {
                  res = Math.max(res, mid - i);
                  left = mid + 1;
              } else {
                  right = mid - 1;
              }
          }
      }
      return res;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
