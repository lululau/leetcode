* [[https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string][1807.
Evaluate the Bracket Pairs of a String]]
  :PROPERTIES:
  :CUSTOM_ID: evaluate-the-bracket-pairs-of-a-string
  :END:
[[./solution/1800-1899/1807.Evaluate the Bracket Pairs of a String/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given a string s that contains some bracket pairs, with each
pair containing a non-empty key.

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

For example, in the string "(name)is(age)yearsold", there are two
bracket pairs that contain the keys "name" and "age".

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

You know the values of a wide range of keys. This is represented by a 2D
string array knowledge where each knowledge[i] = [keyi, valuei]
indicates that key keyi has a value of valuei.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You are tasked to evaluate all of the bracket pairs. When you evaluate a
bracket pair that contains some key keyi, you will:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

Replace keyi and the bracket pair with the key's corresponding valuei.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

If you do not know the value of the key, you will replace keyi and the
bracket pair with a question mark "?" (without the quotation marks).

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

Each key will appear at most once in your knowledge. There will not be
any nested brackets in s.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return the resulting string after evaluating all of the bracket pairs.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> s = &quot;(name)is(age)yearsold&quot;, knowledge = [[&quot;name&quot;,&quot;bob&quot;],[&quot;age&quot;,&quot;two&quot;]]
  <strong>Output:</strong> &quot;bobistwoyearsold&quot;
  <strong>Explanation:</strong>
  The key &quot;name&quot; has a value of &quot;bob&quot;, so replace &quot;(name)&quot; with &quot;bob&quot;.
  The key &quot;age&quot; has a value of &quot;two&quot;, so replace &quot;(age)&quot; with &quot;two&quot;.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> s = &quot;hi(name)&quot;, knowledge = [[&quot;a&quot;,&quot;b&quot;]]
  <strong>Output:</strong> &quot;hi?&quot;
  <strong>Explanation:</strong> As you do not know the value of the key &quot;name&quot;, replace &quot;(name)&quot; with &quot;?&quot;.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> s = &quot;(a)(a)(a)aaa&quot;, knowledge = [[&quot;a&quot;,&quot;yes&quot;]]
  <strong>Output:</strong> &quot;yesyesyesaaa&quot;
  <strong>Explanation:</strong> The same key can appear multiple times.
  The key &quot;a&quot; has a value of &quot;yes&quot;, so replace all occurrences of &quot;(a)&quot; with &quot;yes&quot;.
  Notice that the &quot;a&quot;s not in a bracket pair are not evaluated.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> s = &quot;(a)(b)&quot;, knowledge = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;]]
  <strong>Output:</strong> &quot;ba&quot;</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= s.length <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= knowledge.length <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

knowledge[i].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= keyi.length, valuei.length <= 10

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

s consists of lowercase English letters and round brackets '(' and ')'.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Every open bracket '(' in s will have a corresponding close bracket ')'.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The key in each bracket pair of s will be non-empty.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

There will not be any nested bracket pairs in s.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

keyi and valuei consist of lowercase English letters.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Each keyi in knowledge is unique.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def evaluate(self, s: str, knowledge: List[List[str]]) -> str:
          def find_right_bracket(s, start, end):
              for i in range(start, end):
                  if s[i] == ')':
                      return i
          knowledge_dict = {item[0]: item[1] for item in knowledge}
          res, n = [], len(s)
          i = 0
          while i < n:
              if s[i] == '(':
                  right_bracket_pos = find_right_bracket(s, i + 1, n)
                  key = s[i + 1: right_bracket_pos]
                  res.append(knowledge_dict.get(key, '?'))
                  i = right_bracket_pos + 1
              else:
                  res.append(s[i])
                  i += 1
          return ''.join(res)
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public String evaluate(String s, List<List<String>> knowledge) {
          Map<String, String> knowledgeDict = new HashMap<>();
          for (List<String> item : knowledge) {
              knowledgeDict.put(item.get(0), item.get(1));
          }
          StringBuilder res = new StringBuilder();
          int i = 0, n = s.length();
          while (i < n) {
              if (s.charAt(i) == '(') {
                  int rightBracketPos = findRightBracket(s, i + 1, n);
                  String key = s.substring(i + 1, rightBracketPos);
                  res.append(knowledgeDict.getOrDefault(key, "?"));
                  i = rightBracketPos + 1;
              } else {
                  res.append(s.charAt(i));
                  i += 1;
              }
          }
          return res.toString();
      }

      private int findRightBracket(String s, int start, int end) {
          for (int i =  start; i < end; ++i) {
              if (s.charAt(i) == ')') {
                  return i;
              }
          }
          return -1;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
