* [[https://leetcode.com/problems/minimum-speed-to-arrive-on-time][1870.
Minimum Speed to Arrive on Time]]
  :PROPERTIES:
  :CUSTOM_ID: minimum-speed-to-arrive-on-time
  :END:
[[./solution/1800-1899/1870.Minimum Speed to Arrive on Time/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given a floating-point number hour, representing the amount of
time you have to reach the office. To commute to the office, you must
take n trains in sequential order. You are also given an integer array
dist of length n, where dist[i] describes the distance (in kilometers)
of the ith train ride.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Each train can only depart at an integer hour, so you may need to wait
in between each train ride.

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

For example, if the 1st train ride takes 1.5 hours, you must wait for an
additional 0.5 hours before you can depart on the 2nd train ride at the
2 hour mark.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

Return the minimum positive integer speed (in kilometers per hour) that
all the trains must travel at for you to reach the office on time, or -1
if it is impossible to be on time.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Tests are generated such that the answer will not exceed 107 and hour
will have at most two digits after the decimal point.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> dist = [1,3,2], hour = 6
  <strong>Output:</strong> 1
  <strong>Explanation: </strong>At speed 1:
  - The first train ride takes 1/1 = 1 hour.
  - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
  - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
  - You will arrive at exactly the 6 hour mark.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> dist = [1,3,2], hour = 2.7
  <strong>Output:</strong> 3
  <strong>Explanation: </strong>At speed 3:
  - The first train ride takes 1/3 = 0.33333 hours.
  - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
  - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
  - You will arrive at the 2.66667 hour mark.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> dist = [1,3,2], hour = 1.9
  <strong>Output:</strong> -1
  <strong>Explanation:</strong> It is impossible because the earliest the third train can depart is at the 2 hour mark.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

n == dist.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= dist[i] <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= hour <= 109

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

There will be at most two digits after the decimal point in hour.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def minSpeedOnTime(self, dist: List[int], hour: float) -> int:
          def arrive_on_time(speed):
              res = 0
              for i, d in enumerate(dist):
                  res += (d / speed) if i == len(dist) - 1 else math.ceil(d / speed)
              return res <= hour
          if len(dist) - 1 >= hour:
              return -1
          l, r = 1, 10 ** 7
          while l < r:
              m = (l + r) >> 1
              if arrive_on_time(m):
                  r = m
              else:
                  l = m + 1
          return l
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public int minSpeedOnTime(int[] dist, double hour) {
          if (dist.length - 1 >= hour) {
              return -1;
          }
          int l = 1, r = 10000000;
          while (l < r) {
              int m = (l + r) >> 1;
              if (arriveOnTime(dist, m, hour)) {
                  r = m;
              } else {
                  l = m + 1;
              }
          }
          return l;
      }

      private boolean arriveOnTime(int[] dist, int speed, double hour) {
          double res = 0;
          for (int i = 0; i < dist.length; ++i) {
              double cost = dist[i] * 1.0 / speed;
              res += (i == dist.length - 1 ? cost : Math.ceil(cost));
          }
          return res <= hour;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number[]} dist
   * @param {number} hour
   * @return {number}
   */
   var minSpeedOnTime = function(dist, hour) {
      if (dist.length > Math.ceil(hour)) return -1;
      let left = 1, right = 10 ** 7;
      while (left < right) {
          let mid = (left + right) >> 1;
          if (arriveOnTime(dist, mid, hour)) {
              right = mid;
          } else {
              left = mid + 1;
          }
      }
      return left;
   };
   
   function arriveOnTime (dist, speed, hour) {
      let res = 0.0;
      let n = dist.length;
      for (let i = 0; i < n; i++) {
          let cost = parseFloat(dist[i]) / speed;
          if (i != n - 1) {
              cost = Math.ceil(cost);
          }
          res += cost;
      }
      return res <= hour;
   }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
