* [[https://leetcode-cn.com/problems/bricks-falling-when-hit][803.
打砖块]]
  :PROPERTIES:
  :CUSTOM_ID: 打砖块
  :END:
[[./solution/0800-0899/0803.Bricks Falling When Hit/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

有一个 m x n 的二元网格，其中 1 表示砖块，0 表示空白。砖块
稳定（不会掉落）的前提是：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

一块砖直接连接到网格的顶部，或者

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] =
(rowi, coli)
位置上的砖块时，对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落。一旦砖块掉落，它会立即从网格中消失（即，它不会落在其他稳定的砖块上）。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

返回一个数组 result ，其中 result[i] 表示第 i
次消除操作对应掉落的砖块数目。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]
  <strong>输出：</strong>[2]
  <strong>解释：</strong>
  网格开始为：
  [[1,0,0,0]，
   [<strong>1</strong>,1,1,0]]
  消除 (1,0) 处加粗的砖块，得到网格：
  [[1,0,0,0]
   [0,<strong>1</strong>,<strong>1</strong>,0]]
  两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
  [[1,0,0,0],
   [0,0,0,0]]
  因此，结果为 [2] 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]
  <strong>输出：</strong>[0,0]
  <strong>解释：</strong>
  网格开始为：
  [[1,0,0,0],
   [1,<strong>1</strong>,0,0]]
  消除 (1,1) 处加粗的砖块，得到网格：
  [[1,0,0,0],
   [1,0,0,0]]
  剩下的砖都很稳定，所以不会掉落。网格保持不变：
  [[1,0,0,0], 
   [<strong>1</strong>,0,0,0]]
  接下来消除 (1,0) 处加粗的砖块，得到网格：
  [[1,0,0,0],
   [0,0,0,0]]
  剩下的砖块仍然是稳定的，所以不会有砖块掉落。
  因此，结果为 [0,0] 。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

m == grid.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n == grid[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m, n <= 200

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

grid[i][j] 为 0 或 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= hits.length <= 4 * 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

hits[i].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= xi <= m - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= yi <= n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

所有 (xi, yi) 互不相同

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
