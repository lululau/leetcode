* [[https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph][882.
细分图中的可到达结点]]
  :PROPERTIES:
  :CUSTOM_ID: 细分图中的可到达结点
  :END:
[[./solution/0800-0899/0882.Reachable Nodes In Subdivided Graph/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个无向图（原始图），图中有 n 个节点，编号从 0 到 n - 1
。你决定将图中的每条边细分为一条节点链，每条边之间的新节点数各不相同。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

图用由边组成的二维数组 edges 表示，其中 edges[i] = [ui, vi, cnti]
表示原始图中节点 ui 和 vi 之间存在一条边，cnti
是将边细分后的新节点总数。注意，cnti == 0 表示边不可细分。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

要细分边 [ui, vi] ，需要将其替换为 (cnti + 1) 条新边，和 cnti
个新节点。新节点为 x1, x2, ..., xcnti ，新边为 [ui, x1], [x1, x2], [x2,
x3], ..., [xcnti+1, xcnti], [xcnti, vi] 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p class="MachineTrans-lang-zh-CN">
#+end_html

现在得到一个新的 细分图 ，请你计算从节点 0
出发，可以到达多少个节点？节点 是否可以到达的判断条件
为：如果节点间距离是 maxMoves 或更少，则视为可以到达；否则，不可到达。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p class="MachineTrans-lang-zh-CN">
#+end_html

给你原始图和 maxMoves ，返回新的细分图中从节点 0 出发 可到达的节点数 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3
  <strong>输出：</strong>13
  <strong>解释：</strong>边的细分情况如上图所示。
  可以到达的节点已经用黄色标注出来。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4
  <strong>输出：</strong>23
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5
  <strong>输出：</strong>1
  <strong>解释：</strong>节点 0 与图的其余部分没有连通，所以只有节点 0 可以到达。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= edges.length <= min(n * (n - 1) / 2, 104)

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges[i].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= ui < vi < n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

图中 不存在平行边

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= cnti <= 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= maxMoves <= 109

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 3000

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
