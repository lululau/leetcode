* [[https://leetcode.com/problems/leaf-similar-trees][872. Leaf-Similar
Trees]]
  :PROPERTIES:
  :CUSTOM_ID: leaf-similar-trees
  :END:
[[./solution/0800-0899/0872.Leaf-Similar Trees/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Consider all the leaves of a binary tree, from left to right order, the
values of those leaves form a leaf value sequence.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

For example, in the given tree above, the leaf value sequence is (6, 7,
4, 9, 8).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Two binary trees are considered leaf-similar if their leaf value
sequence is the same.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return true if and only if the two given trees with head nodes root1 and
root2 are leaf-similar.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
  <strong>Output:</strong> true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root1 = [1], root2 = [1]
  <strong>Output:</strong> true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root1 = [1], root2 = [2]
  <strong>Output:</strong> false
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root1 = [1,2], root2 = [2,2]
  <strong>Output:</strong> true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 5:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]
  <strong>Output:</strong> false
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The number of nodes in each tree will be in the range [1, 200].

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Both of the given trees will have values in the range [0, 200].

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
          def dfs(root, leaves):
              if root is None:
                  return
              if root.left is None and root.right is None:
                  leaves.append(root.val)
                  return
              dfs(root.left, leaves)
              dfs(root.right, leaves)
          l1, l2 = [], []
          dfs(root1, l1)
          dfs(root2, l2)
          return l1 == l2
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      public boolean leafSimilar(TreeNode root1, TreeNode root2) {
          List<Integer> l1 = new ArrayList<>();
          List<Integer> l2 = new ArrayList<>();
          dfs(root1, l1);
          dfs(root2, l2);
          return l1.equals(l2);
      }

      private void dfs(TreeNode root, List<Integer> leaves) {
          if (root == null) return;
          if (root.left == null && root.right == null) {
              leaves.add(root.val);
              return;
          }
          dfs(root.left, leaves);
          dfs(root.right, leaves);
      }
  }
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool {
      var l1, l2 []int
      if root1 != nil {
          dfs(root1, &l1)
      }
      if root2 != nil {
          dfs(root2, &l2)
      }
      return reflect.DeepEqual(l1, l2)
  }

  func dfs(root *TreeNode, leaves *[]int) {
      if root.Left == nil && root.Right == nil {
          *leaves = append(*leaves, root.Val)
      } else {
          if root.Left != nil {
              dfs(root.Left, leaves)
          }
          if root.Right != nil {
              dfs(root.Right, leaves)
          }
      }
  }
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
