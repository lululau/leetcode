* [[https://leetcode-cn.com/problems/leaf-similar-trees][872.
叶子相似的树]]
  :PROPERTIES:
  :CUSTOM_ID: 叶子相似的树
  :END:
[[./solution/0800-0899/0872.Leaf-Similar Trees/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列
。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

如果给定的两个头结点分别为 root1
和 root2 的树是叶相似的，则返回 true；否则返回 false 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
  <strong>输出：</strong>true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>root1 = [1], root2 = [1]
  <strong>输出：</strong>true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>root1 = [1], root2 = [2]
  <strong>输出：</strong>false
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>root1 = [1,2], root2 = [2,2]
  <strong>输出：</strong>true
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 5：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>root1 = [1,2,3], root2 = [1,3,2]
  <strong>输出：</strong>false
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

给定的两棵树可能会有 1 到 200 个结点。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

给定的两棵树上的值介于 0 到 200 之间。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

深度优先搜索。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
          def dfs(root, leaves):
              if root is None:
                  return
              if root.left is None and root.right is None:
                  leaves.append(root.val)
                  return
              dfs(root.left, leaves)
              dfs(root.right, leaves)
          l1, l2 = [], []
          dfs(root1, l1)
          dfs(root2, l2)
          return l1 == l2
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class Solution {
      public boolean leafSimilar(TreeNode root1, TreeNode root2) {
          List<Integer> l1 = new ArrayList<>();
          List<Integer> l2 = new ArrayList<>();
          dfs(root1, l1);
          dfs(root2, l2);
          return l1.equals(l2);
      }

      private void dfs(TreeNode root, List<Integer> leaves) {
          if (root == null) return;
          if (root.left == null && root.right == null) {
              leaves.add(root.val);
              return;
          }
          dfs(root.left, leaves);
          dfs(root.right, leaves);
      }
  }
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool {
      var l1, l2 []int
      if root1 != nil {
          dfs(root1, &l1)
      }
      if root2 != nil {
          dfs(root2, &l2)
      }
      return reflect.DeepEqual(l1, l2)
  }

  func dfs(root *TreeNode, leaves *[]int) {
      if root.Left == nil && root.Right == nil {
          *leaves = append(*leaves, root.Val)
      } else {
          if root.Left != nil {
              dfs(root.Left, leaves)
          }
          if root.Right != nil {
              dfs(root.Right, leaves)
          }
      }
  }
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
