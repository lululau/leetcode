* [[https://leetcode-cn.com/problems/find-duplicate-file-in-system][609.
在系统中查找重复文件]]
  :PROPERTIES:
  :CUSTOM_ID: 在系统中查找重复文件
  :END:
[[./solution/0600-0699/0609.Find Duplicate File in System/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容的文件。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

输入列表中的单个目录信息字符串的格式如下：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ...
fn.txt(fn_content)"

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

这意味着有 n 个文件（f1.txt, f2.txt ... fn.txt 的内容分别是
f1_content, f2_content ... fn_content）在目录 root/d1/d2/.../dm 下。注意：n>=1
且 m>=0。如果 m=0，则表示该目录是根目录。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

"directory_path/file_name.txt"

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>
  [&quot;root/a 1.txt(abcd) 2.txt(efgh)&quot;, &quot;root/c 3.txt(abcd)&quot;, &quot;root/c/d 4.txt(efgh)&quot;, &quot;root 4.txt(efgh)&quot;]
  <strong>输出：</strong>  
  [[&quot;root/a/2.txt&quot;,&quot;root/c/d/4.txt&quot;,&quot;root/4.txt&quot;],[&quot;root/a/1.txt&quot;,&quot;root/c/3.txt&quot;]]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

最终输出不需要顺序。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

您可以假设目录名、文件名和文件内容只有字母和数字，并且文件内容的长度在
[1，50] 的范围内。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

给定的文件数量在 [1，20000] 个范围内。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

您可以假设在同一目录中没有任何文件或目录共享相同的名称。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

您可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用一个空格分隔。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

超越竞赛的后续行动：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果文件内容非常大（GB级别），您将如何修改您的解决方案？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果每次只能读取 1 kb 的文件，您将如何修改解决方案？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如何确保您发现的重复文件不是误报？

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
