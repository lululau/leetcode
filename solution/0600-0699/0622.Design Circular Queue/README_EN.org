* [[https://leetcode.com/problems/design-circular-queue][622. Design
Circular Queue]]
  :PROPERTIES:
  :CUSTOM_ID: design-circular-queue
  :END:
[[./solution/0600-0699/0622.Design Circular Queue/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Design your implementation of the circular queue. The circular queue is
a linear data structure in which the operations are performed based on
FIFO (First In First Out) principle and the last position is connected
back to the first position to make a circle. It is also called "Ring
Buffer".

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

One of the benefits of the circular queue is that we can make use of the
spaces in front of the queue. In a normal queue, once the queue becomes
full, we cannot insert the next element even if there is a space in
front of the queue. But using the circular queue, we can use the space
to store new values.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Implementation the MyCircularQueue class:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

MyCircularQueue(k) Initializes the object with the size of the queue to
be k.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int Front() Gets the front item from the queue. If the queue is empty,
return -1.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int Rear() Gets the last item from the queue. If the queue is empty,
return -1.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

boolean enQueue(int value) Inserts an element into the circular queue.
Return true if the operation is successful.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

boolean deQueue() Deletes an element from the circular queue. Return
true if the operation is successful.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

boolean isEmpty() Checks whether the circular queue is empty or not.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

boolean isFull() Checks whether the circular queue is full or not.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input</strong>
  [&quot;MyCircularQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;, &quot;isFull&quot;, &quot;deQueue&quot;, &quot;enQueue&quot;, &quot;Rear&quot;]
  [[3], [1], [2], [3], [4], [], [], [], [4], []]
  <strong>Output</strong>
  [null, true, true, true, false, 3, true, true, true, 4]

  <strong>Explanation</strong>
  MyCircularQueue myCircularQueue = new MyCircularQueue(3);
  myCircularQueue.enQueue(1); // return True
  myCircularQueue.enQueue(2); // return True
  myCircularQueue.enQueue(3); // return True
  myCircularQueue.enQueue(4); // return False
  myCircularQueue.Rear();     // return 3
  myCircularQueue.isFull();   // return True
  myCircularQueue.deQueue();  // return True
  myCircularQueue.enQueue(4); // return True
  myCircularQueue.Rear();     // return 4
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= k <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= value <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

At most 3000 calls will be made to enQueue,
deQueue, Front, Rear, isEmpty, and isFull.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

Follow up: Could you solve the problem without using the built-in
queue? 

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class MyCircularQueue:

      def __init__(self, k: int):
          self.q = [0] * k
          self.front = 0
          self.size = 0
          self.capacity = k

      def enQueue(self, value: int) -> bool:
          if self.isFull():
              return False
          idx = (self.front + self.size) % self.capacity
          self.q[idx] = value
          self.size += 1
          return True

      def deQueue(self) -> bool:
          if self.isEmpty():
              return False
          self.front = (self.front + 1) % self.capacity
          self.size -= 1
          return True

      def Front(self) -> int:
          if self.isEmpty():
              return -1
          return self.q[self.front]

      def Rear(self) -> int:
          if self.isEmpty():
              return -1
          idx = (self.front + self.size - 1) % self.capacity
          return self.q[idx]

      def isEmpty(self) -> bool:
          return self.size == 0

      def isFull(self) -> bool:
          return self.size == self.capacity


  # Your MyCircularQueue object will be instantiated and called as such:
  # obj = MyCircularQueue(k)
  # param_1 = obj.enQueue(value)
  # param_2 = obj.deQueue()
  # param_3 = obj.Front()
  # param_4 = obj.Rear()
  # param_5 = obj.isEmpty()
  # param_6 = obj.isFull()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class MyCircularQueue {
      private int[] q;
      private int front;
      private int size;
      private int capacity;

      public MyCircularQueue(int k) {
          q = new int[k];
          capacity = k;
      }
      
      public boolean enQueue(int value) {
          if (isFull()) {
              return false;
          }
          int idx = (front + size) % capacity;
          q[idx] = value;
          ++size;
          return true;
      }
      
      public boolean deQueue() {
          if (isEmpty()) {
              return false;
          }
          front = (front + 1) % capacity;
          --size;
          return true;
      }
      
      public int Front() {
          if (isEmpty()) {
              return -1;
          }
          return q[front];
      }
      
      public int Rear() {
          if (isEmpty()) {
              return -1;
          }
          int idx = (front + size - 1) % capacity;
          return q[idx];
      }
      
      public boolean isEmpty() {
          return size == 0;
      }
      
      public boolean isFull() {
          return size == capacity;
      }
  }

  /**
   * Your MyCircularQueue object will be instantiated and called as such:
   * MyCircularQueue obj = new MyCircularQueue(k);
   * boolean param_1 = obj.enQueue(value);
   * boolean param_2 = obj.deQueue();
   * int param_3 = obj.Front();
   * int param_4 = obj.Rear();
   * boolean param_5 = obj.isEmpty();
   * boolean param_6 = obj.isFull();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
