* [[https://leetcode-cn.com/problems/design-circular-queue][622.
设计循环队列]]
  :PROPERTIES:
  :CUSTOM_ID: 设计循环队列
  :END:
[[./solution/0600-0699/0622.Design Circular Queue/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于
FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

你的实现应该支持如下操作：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

MyCircularQueue(k): 构造器，设置队列长度为 k 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Front: 从队首获取元素。如果队列为空，返回 -1 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Rear: 获取队尾元素。如果队列为空，返回 -1 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

isEmpty(): 检查循环队列是否为空。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

isFull(): 检查循环队列是否已满。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
  circularQueue.enQueue(1); &nbsp;// 返回 true
  circularQueue.enQueue(2); &nbsp;// 返回 true
  circularQueue.enQueue(3); &nbsp;// 返回 true
  circularQueue.enQueue(4); &nbsp;// 返回 false，队列已满
  circularQueue.Rear(); &nbsp;// 返回 3
  circularQueue.isFull(); &nbsp;// 返回 true
  circularQueue.deQueue(); &nbsp;// 返回 true
  circularQueue.enQueue(4); &nbsp;// 返回 true
  circularQueue.Rear(); &nbsp;// 返回 4</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

所有的值都在 0 至 1000 的范围内；

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

操作数将在 1 至 1000 的范围内；

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

请不要使用内置的队列库。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

"循环数组"实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class MyCircularQueue:

      def __init__(self, k: int):
          self.q = [0] * k
          self.front = 0
          self.size = 0
          self.capacity = k

      def enQueue(self, value: int) -> bool:
          if self.isFull():
              return False
          idx = (self.front + self.size) % self.capacity
          self.q[idx] = value
          self.size += 1
          return True

      def deQueue(self) -> bool:
          if self.isEmpty():
              return False
          self.front = (self.front + 1) % self.capacity
          self.size -= 1
          return True

      def Front(self) -> int:
          if self.isEmpty():
              return -1
          return self.q[self.front]

      def Rear(self) -> int:
          if self.isEmpty():
              return -1
          idx = (self.front + self.size - 1) % self.capacity
          return self.q[idx]

      def isEmpty(self) -> bool:
          return self.size == 0

      def isFull(self) -> bool:
          return self.size == self.capacity


  # Your MyCircularQueue object will be instantiated and called as such:
  # obj = MyCircularQueue(k)
  # param_1 = obj.enQueue(value)
  # param_2 = obj.deQueue()
  # param_3 = obj.Front()
  # param_4 = obj.Rear()
  # param_5 = obj.isEmpty()
  # param_6 = obj.isFull()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class MyCircularQueue {
      private int[] q;
      private int front;
      private int size;
      private int capacity;

      public MyCircularQueue(int k) {
          q = new int[k];
          capacity = k;
      }
      
      public boolean enQueue(int value) {
          if (isFull()) {
              return false;
          }
          int idx = (front + size) % capacity;
          q[idx] = value;
          ++size;
          return true;
      }
      
      public boolean deQueue() {
          if (isEmpty()) {
              return false;
          }
          front = (front + 1) % capacity;
          --size;
          return true;
      }
      
      public int Front() {
          if (isEmpty()) {
              return -1;
          }
          return q[front];
      }
      
      public int Rear() {
          if (isEmpty()) {
              return -1;
          }
          int idx = (front + size - 1) % capacity;
          return q[idx];
      }
      
      public boolean isEmpty() {
          return size == 0;
      }
      
      public boolean isFull() {
          return size == capacity;
      }
  }

  /**
   * Your MyCircularQueue object will be instantiated and called as such:
   * MyCircularQueue obj = new MyCircularQueue(k);
   * boolean param_1 = obj.enQueue(value);
   * boolean param_2 = obj.deQueue();
   * int param_3 = obj.Front();
   * int param_4 = obj.Rear();
   * boolean param_5 = obj.isEmpty();
   * boolean param_6 = obj.isFull();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
