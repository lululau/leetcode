* [[https://leetcode-cn.com/problems/falling-squares][699. 掉落的方块]]
  :PROPERTIES:
  :CUSTOM_ID: 掉落的方块
  :END:
[[./solution/0600-0699/0699.Falling Squares/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

在无限长的数轴（即 x 轴）上，我们根据给定的顺序放置对应的正方形方块。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

第 i 个掉落的方块（positions[i] = (left,
side_length)）是正方形，其中 left
表示该方块最左边的点位置(positions[i][0])，side_length
表示该方块的边长(positions[i][1])。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

每个方块的底部边缘平行于数轴（即 x
轴），并且从一个比目前所有的落地方块更高的高度掉落而下。在上一个方块结束掉落，并保持静止后，才开始掉落新方块。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

方块的底边具有非常大的粘性，并将保持固定在它们所接触的任何长度表面上（无论是数轴还是其他方块）。邻接掉落的边不会过早地粘合在一起，因为只有底边才具有粘性。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

返回一个堆叠高度列表 ans
。每一个堆叠高度 ans[i] 表示在通过 positions[0], positions[1], ...,
positions[i] 表示的方块掉落结束后，目前所有已经落稳的方块堆叠的最高高度。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> [[1, 2], [2, 3], [6, 1]]
  <strong>输出:</strong> [2, 5, 5]
  <strong>解释:

  </strong>第一个方块 <code>positions[0] = [1, 2] </code>掉落：
  <code>_aa
  _aa
  -------
  </code>方块最大高度为 2 。

  第二个方块 <code>positions[1] = [2, 3] </code>掉落：
  <code>__aaa
  __aaa
  __aaa
  _aa__
  _aa__
  --------------
  </code>方块最大高度为5。
  大的方块保持在较小的方块的顶部，不论它的重心在哪里，因为方块的底部边缘有非常大的粘性。

  第三个方块 <code>positions[1] = [6, 1] </code>掉落：
  <code>__aaa
  __aaa
  __aaa
  _aa
  _aa___a
  -------------- 
  </code>方块最大高度为5。

  因此，我们返回结果<code>[2, 5, 5]。</code>
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> [[100, 100], [200, 100]]
  <strong>输出:</strong> [100, 100]
  <strong>解释:</strong> 相邻的方块不会过早地卡住，只有它们的底部边缘才能粘在表面上。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注意:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= positions.length <= 1000.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= positions[i][0] <= 10^8.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= positions[i][1] <= 10^6.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
