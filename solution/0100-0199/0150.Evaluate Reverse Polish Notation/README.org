* [[https://leetcode-cn.com/problems/evaluate-reverse-polish-notation][150.
逆波兰表达式求值]]
  :PROPERTIES:
  :CUSTOM_ID: 逆波兰表达式求值
  :END:
[[./solution/0100-0199/0150.Evaluate Reverse Polish Notation/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

根据 逆波兰表示法，求表达式的值。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

整数除法只保留整数部分。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为
0 的情况。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>tokens = ["2","1","+","3","*"]
  <strong>输出：</strong>9
  <strong>解释：</strong>该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>tokens = ["4","13","5","/","+"]
  <strong>输出：</strong>6
  <strong>解释：</strong>该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
  <strong>输出：</strong>22
  <strong>解释：</strong>
  该算式转化为常见的中缀算术表达式为：
    ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
  = ((10 * (6 / (12 * -11))) + 17) + 5
  = ((10 * (6 / -132)) + 17) + 5
  = ((10 * 0) + 17) + 5
  = (0 + 17) + 5
  = 17 + 5
  = 22</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= tokens.length <= 104

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

tokens[i] 要么是一个算符（"+"、"-"、“*" 或 "/“），要么是一个在范围
[-200, 200] 内的整数

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

逆波兰表达式：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

逆波兰表达式主要有以下两个优点：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + *
也可以依据次序计算出正确结果。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

栈实现。

遍历数组，遇到数字则压入栈中，遇到运算符号，则从栈中弹出右、左操作数，运算过后，将结果压入栈中。

遍历结束后，返回栈中的唯一元素。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  import operator

  class Solution:
      def evalRPN(self, tokens: List[str]) -> int:
          opt = {
              "+": operator.add,
              "-": operator.sub,
              "*": operator.mul,
              "/": operator.truediv
          }
          s = []
          for token in tokens:
              if token in opt:
                  s.append(int(opt[token](s.pop(-2), s.pop(-1))))
              else:
                  s.append(int(token))
          return s[0]
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int evalRPN(String[] tokens) {
          Deque<Integer> s = new ArrayDeque<>();
          int left, right;
          for (String token : tokens) {
              switch(token) {
              case "+":
                  right = s.pop();
                  left = s.pop();
                  s.push(left + right);
                  break;
              case "-":
                  right = s.pop();
                  left = s.pop();
                  s.push(left - right);
                  break;
              case "*":
                  right = s.pop();
                  left = s.pop();
                  s.push(left * right);
                  break;
              case "/":
                  right = s.pop();
                  left = s.pop();
                  s.push(left / right);
                  break;
              default:
                  s.push(Integer.valueOf(token));
              }
          }
          return s.pop();
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
