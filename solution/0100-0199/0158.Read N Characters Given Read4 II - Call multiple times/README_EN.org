* [[https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times][158.
Read N Characters Given Read4 II - Call multiple times]]
  :PROPERTIES:
  :CUSTOM_ID: read-n-characters-given-read4-ii---call-multiple-times
  :END:
[[./solution/0100-0199/0158.Read N Characters Given Read4 II - Call multiple times/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Given a file and assume that you can only read the file using a given
method read4, implement a method read to read n characters. Your method
read may be called multiple times.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Method read4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The API read4 reads four consecutive characters from file, then writes
those characters into the buffer array buf4.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The return value is the number of actual characters read.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Note that read4() has its own file pointer, much like FILE *fp in C.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Definition of read4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
      Parameter:  char[] buf4
      Returns:    int

  buf4[] is a destination, not a source. The results from read4 will be copied to buf4[].
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Below is a high-level example of how read4 works:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  File file(&quot;abcde<code>&quot;); // File is &quot;</code>abcde<code>&quot;, initially file pointer (fp) points to &#39;a&#39;
  char[] buf4 = new char[4]; // Create buffer with enough space to store characters
  read4(buf4); // read4 returns 4. Now buf4 = &quot;abcd&quot;, fp points to &#39;e&#39;
  read4(buf4); // read4 returns 1. Now buf4 = &quot;e&quot;, fp points to end of file
  read4(buf4); // read4 returns 0. Now buf4 = &quot;&quot;, fp points to end of file</code>
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Method read:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

By using the read4 method, implement the method read that reads n
characters from file and store it in the buffer array buf. Consider that
you cannot manipulate file directly.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The return value is the number of actual characters read.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Definition of read:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
      Parameters: char[] buf, int n
      Returns:    int

  buf[] is a destination, not a source. You will need to write the results to buf[].
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Note:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

Consider that you cannot manipulate the file directly. The file is only
accessible for read4 but not for read.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The read function may be called multiple times.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Please remember to RESET your class variables declared in Solution, as
static/class variables are persisted across multiple test cases. Please
see here for more details.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

You may assume the destination buffer array, buf, is guaranteed to have
enough space for storing n characters.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

It is guaranteed that in a given test case the same buffer buf is called
by read.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> file = &quot;abc&quot;, queries = [1,2,1]
  <strong>Output:</strong> [1,2,0]
  <strong>Explanation:</strong> The test case represents the following scenario:
  File file(&quot;abc&quot;);
  Solution sol;
  sol.read(buf, 1); // After calling your read method, buf should contain &quot;a&quot;. We read a total of 1 character from the file, so return 1.
  sol.read(buf, 2); // Now buf should contain &quot;bc&quot;. We read a total of 2 characters from the file, so return 2.
  sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.
  Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> file = &quot;abc&quot;, queries = [4,1]
  <strong>Output:</strong> [3,0]
  <strong>Explanation:</strong> The test case represents the following scenario:
  File file(&quot;abc&quot;);
  Solution sol;
  sol.read(buf, 4); // After calling your read method, buf should contain &quot;abc&quot;. We read a total of 3 characters from the file, so return 3.
  sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= file.length <= 500

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

file consist of English letters and digits.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= queries.length <= 10

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= queries[i] <= 500

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
