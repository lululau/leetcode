* [[https://leetcode-cn.com/problems/binary-search-tree-iterator][173.
二叉搜索树迭代器]]
  :PROPERTIES:
  :CUSTOM_ID: 二叉搜索树迭代器
  :END:
[[./solution/0100-0199/0173.Binary Search Tree Iterator/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

实现一个二叉搜索树迭代器类BSTIterator
，表示一个按中序遍历二叉搜索树（BST）的迭代器：

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点
root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST
中的数字，且该数字小于 BST 中的任何元素。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回
false 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int next()将指针向右移动，然后返回指针处的数字。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

注意，指针初始化为一个不存在于 BST 中的数字，所以对 next()
的首次调用将返回 BST 中的最小元素。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST
的中序遍历中至少存在一个下一个数字。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入</strong>
  ["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
  [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
  <strong>输出</strong>
  [null, 3, 7, true, 9, true, 15, true, 20, false]

  <strong>解释</strong>
  BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
  bSTIterator.next();    // 返回 3
  bSTIterator.next();    // 返回 7
  bSTIterator.hasNext(); // 返回 True
  bSTIterator.next();    // 返回 9
  bSTIterator.hasNext(); // 返回 True
  bSTIterator.next();    // 返回 15
  bSTIterator.hasNext(); // 返回 True
  bSTIterator.next();    // 返回 20
  bSTIterator.hasNext(); // 返回 False
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

树中节点的数目在范围 [1, 105] 内

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= Node.val <= 106

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

最多调用 105 次 hasNext 和 next 操作

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

进阶：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

你可以设计一个满足下述条件的解决方案吗？next() 和 hasNext()
操作均摊时间复杂度为 O(1) ，并使用 O(h) 内存。其中 h 是树的高度。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

初始化数据时，递归中序遍历，将二叉搜索树每个结点的值保存在列表 =vals=
中。用 =cur/next= 指针记录外部即将遍历的位置，初始化为 0。

调用 =next()= 时，返回 =vals[cur]=，同时 =cur= 指针自增。调用
=hasNext()= 时，判断 =cur= 指针是否已经达到 =vals=
个数，若是，说明已经遍历结束，返回 false，否则返回 true。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class BSTIterator:

      def __init__(self, root: TreeNode):
          def inorder(root):
              if root is None:
                  return
              inorder(root.left)
              self.vals.append(root.val)
              inorder(root.right)

          self.cur = 0
          self.vals = []
          inorder(root)

      def next(self) -> int:
          res = self.vals[self.cur]
          self.cur += 1
          return res

      def hasNext(self) -> bool:
          return self.cur < len(self.vals)


  # Your BSTIterator object will be instantiated and called as such:
  # obj = BSTIterator(root)
  # param_1 = obj.next()
  # param_2 = obj.hasNext()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode() {}
   *     TreeNode(int val) { this.val = val; }
   *     TreeNode(int val, TreeNode left, TreeNode right) {
   *         this.val = val;
   *         this.left = left;
   *         this.right = right;
   *     }
   * }
   */
  class BSTIterator {

      private List<Integer> vals;
      private int next;

      public BSTIterator(TreeNode root) {
          next = 0;
          vals = new ArrayList<>();
          inorder(root);
      }

      public int next() {
          return vals.get(next++);
      }

      public boolean hasNext() {
          return next < vals.size();
      }

      private void inorder(TreeNode root) {
          if (root == null) {
              return;
          }
          inorder(root.left);
          vals.add(root.val);
          inorder(root.right);
      }
  }

  /**
   * Your BSTIterator object will be instantiated and called as such:
   * BSTIterator obj = new BSTIterator(root);
   * int param_1 = obj.next();
   * boolean param_2 = obj.hasNext();
   */
#+end_src

** *JavaScript*
   :PROPERTIES:
   :CUSTOM_ID: javascript
   :END:
#+begin_src js
  /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   *     this.val = (val===undefined ? 0 : val)
   *     this.left = (left===undefined ? null : left)
   *     this.right = (right===undefined ? null : right)
   * }
   */
  /**
   * @param {TreeNode} root
   */
  var BSTIterator = function (root) {
      this.stk = [];
      this.cur = root;
  }


  /**
   * @return {number}
   */
  BSTIterator.prototype.next = function () {
      while (this.cur) {
          this.stk.push(this.cur);
          this.cur = this.cur.left;
      }
      this.cur = this.stk.pop();
      let res = this.cur.val;
      this.cur = this.cur.right;
      return (res);
  };

  /**
   * @return {boolean}
   */
  BSTIterator.prototype.hasNext = function () {
      if (this.stk.length === 0 && this.cur === null) return false;
      return true;
  };

  /**
   * Your BSTIterator object will be instantiated and called as such:
   * var obj = new BSTIterator(root)
   * var param_1 = obj.next()
   * var param_2 = obj.hasNext()
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
