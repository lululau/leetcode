* [[https://leetcode.com/problems/min-stack][155. Min Stack]]
  :PROPERTIES:
  :CUSTOM_ID: min-stack
  :END:
[[./solution/0100-0199/0155.Min Stack/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Design a stack that supports push, pop, top, and retrieving the minimum
element in constant time.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Implement the MinStack class:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

MinStack() initializes the stack object.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

void push(val) pushes the element val onto the stack.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

void pop() removes the element on the top of the stack.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int top() gets the top element of the stack.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int getMin() retrieves the minimum element in the stack.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input</strong>
  [&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
  [[],[-2],[0],[-3],[],[],[],[]]

  <strong>Output</strong>
  [null,null,null,null,-3,null,0,-2]

  <strong>Explanation</strong>
  MinStack minStack = new MinStack();
  minStack.push(-2);
  minStack.push(0);
  minStack.push(-3);
  minStack.getMin(); // return -3
  minStack.pop();
  minStack.top();    // return 0
  minStack.getMin(); // return -2
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

-231 <= val <= 231 - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Methods pop, top and getMin operations will always be called on
non-empty stacks.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

At most 3 * 104 calls will be made to push, pop, top, and getMin.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class MinStack:

      def __init__(self):
          """
          initialize your data structure here.
          """
          self.s = []
          self.mins = [float('inf')]

      def push(self, val: int) -> None:
          self.s.append(val)
          self.mins.append(min(self.mins[-1], val))

      def pop(self) -> None:
          self.s.pop()
          self.mins.pop()

      def top(self) -> int:
          return self.s[-1]

      def getMin(self) -> int:
          return self.mins[-1]


  # Your MinStack object will be instantiated and called as such:
  # obj = MinStack()
  # obj.push(val)
  # obj.pop()
  # param_3 = obj.top()
  # param_4 = obj.getMin()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class MinStack {
      private Deque<Integer> s;
      private Deque<Integer> mins;

      /** initialize your data structure here. */
      public MinStack() {
          s = new ArrayDeque<>();
          mins = new ArrayDeque<>();
          mins.push(Integer.MAX_VALUE);
      }

      public void push(int val) {
          s.push(val);
          mins.push(Math.min(mins.peek(), val));
      }

      public void pop() {
          s.pop();
          mins.pop();
      }

      public int top() {
          return s.peek();
      }

      public int getMin() {
          return mins.peek();
      }
  }

  /**
   * Your MinStack object will be instantiated and called as such:
   * MinStack obj = new MinStack();
   * obj.push(val);
   * obj.pop();
   * int param_3 = obj.top();
   * int param_4 = obj.getMin();
   */
#+end_src

*** *C++*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_src cpp
  class MinStack {
  private:
      stack<int> s;
      stack<int> mins;

  public:
      /** initialize your data structure here. */
      MinStack() {
          mins.push(INT_MAX);
      }

      void push(int val) {
          s.push(val);
          mins.push(min(mins.top(), val));
      }

      void pop() {
          s.pop();
          mins.pop();
      }

      int top() {
          return s.top();
      }

      int getMin() {
          return mins.top();
      }
  };

  /**
   * Your MinStack object will be instantiated and called as such:
   * MinStack* obj = new MinStack();
   * obj->push(val);
   * obj->pop();
   * int param_3 = obj->top();
   * int param_4 = obj->getMin();
   */
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * initialize your data structure here.
   */
  var MinStack = function() {
      this.s = [];
      this.mins = [Infinity];
  };

  /** 
   * @param {number} val
   * @return {void}
   */
  MinStack.prototype.push = function(val) {
      this.s.push(val);
      this.mins.push(Math.min(this.mins[this.mins.length - 1], val));
  };

  /**
   * @return {void}
   */
  MinStack.prototype.pop = function() {
      this.s.pop();
      this.mins.pop();
  };

  /**
   * @return {number}
   */
  MinStack.prototype.top = function() {
      return this.s[this.s.length - 1];
  };

  /**
   * @return {number}
   */
  MinStack.prototype.getMin = function() {
      return this.mins[this.mins.length - 1];
  };

  /**
   * Your MinStack object will be instantiated and called as such:
   * var obj = new MinStack()
   * obj.push(val)
   * obj.pop()
   * var param_3 = obj.top()
   * var param_4 = obj.getMin()
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
