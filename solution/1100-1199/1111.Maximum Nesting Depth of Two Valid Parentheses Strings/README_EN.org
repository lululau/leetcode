* [[https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings][1111.
Maximum Nesting Depth of Two Valid Parentheses Strings]]
  :PROPERTIES:
  :CUSTOM_ID: maximum-nesting-depth-of-two-valid-parentheses-strings
  :END:
[[./solution/1100-1199/1111.Maximum Nesting Depth of Two Valid Parentheses Strings/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

A string is a valid parentheses string (denoted VPS) if and only if it
consists of "(" and ")" characters only, and:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

It is the empty string, or

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

It can be written as AB (A concatenated with B), where A and B are
VPS's, or

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

It can be written as (A), where A is a VPS.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

We can similarly define the nesting depth depth(S) of any VPS S as
follows:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

depth("") = 0

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

depth(A + B) = max(depth(A), depth(B)), where A and B are VPS's

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

depth("(" + A + ")") = 1 + depth(A), where A is a VPS.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

For example,  "", "()()", and "()(()())" are VPS's (with nesting depths
0, 1, and 2), and ")(" and "(()" are not VPS's.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Given a VPS seq, split it into two disjoint subsequences A and B, such
that A and B are VPS's (and A.length + B.length = seq.length).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Now choose any such A and B such that max(depth(A), depth(B)) is the
minimum possible value.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return an answer array (of length seq.length) that encodes such a choice
of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1. 
Note that even though multiple answers may exist, you may return any of
them.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> seq = &quot;(()())&quot;
  <strong>Output:</strong> [0,1,1,1,1,0]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> seq = &quot;()(())()&quot;
  <strong>Output:</strong> [0,0,0,1,1,0,1,1]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= seq.size <= 10000

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
