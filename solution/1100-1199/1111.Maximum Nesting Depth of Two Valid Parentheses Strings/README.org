* [[https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings][1111.
有效括号的嵌套深度]]
  :PROPERTIES:
  :CUSTOM_ID: 有效括号的嵌套深度
  :END:
[[./solution/1100-1199/1111.Maximum Nesting Depth of Two Valid Parentheses Strings/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

有效括号字符串
定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A)
表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

有效括号字符串类型与对应的嵌套深度计算方法如下图所示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

给你一个「有效括号字符串」
seq，请你将其分成两个不相交的有效括号字符串，A
和 B，并使这两个字符串的深度最小。

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B
。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

A 或 B 中的元素在原字符串中可以不连续。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

A.length + B.length = seq.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

深度最小：max(depth(A), depth(B)) 的可能取值最小。 

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

answer[i] = 0，seq[i] 分给 A 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

answer[i] = 1，seq[i] 分给 B 。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

如果存在多个满足要求的答案，只需返回其中任意 一个 即可。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>seq = &quot;(()())&quot;
  <strong>输出：</strong>[0,1,1,1,1,0]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>seq = &quot;()(())()&quot;
  <strong>输出：</strong>[0,0,0,1,1,0,1,1]
  <strong>解释：</strong>本示例答案不唯一。
  按此输出 A = &quot;()()&quot;, B = &quot;()()&quot;, max(depth(A), depth(B)) = 1，它们的深度最小。
  像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = &quot;()()()&quot;, B = &quot;()&quot;, max(depth(A), depth(B)) = 1 。 
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 < seq.size <= 10000

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

有效括号字符串：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>仅由&nbsp;<code>&quot;(&quot;</code> 和&nbsp;<code>&quot;)&quot;</code>&nbsp;构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。
  下述几种情况同样属于有效括号字符串：

    1. 空字符串
    2. 连接，可以记作&nbsp;<code>AB</code>（<code>A</code> 与 <code>B</code> 连接），其中&nbsp;<code>A</code>&nbsp;和&nbsp;<code>B</code>&nbsp;都是有效括号字符串
    3. 嵌套，可以记作&nbsp;<code>(A)</code>，其中&nbsp;<code>A</code>&nbsp;是有效括号字符串
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

嵌套深度：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>类似地，我们可以定义任意有效括号字符串 <code>s</code> 的 <strong>嵌套深度</strong>&nbsp;<code>depth(S)</code>：

    1.<code> s</code> 为空时，<code>depth(&quot;&quot;) = 0</code>
  <code>  2. s</code> 为 <code>A</code> 与 <code>B</code> 连接时，<code>depth(A + B) = max(depth(A), depth(B))</code>，其中&nbsp;<code>A</code> 和&nbsp;<code>B</code>&nbsp;都是有效括号字符串
  <code>  3. s</code> 为嵌套情况，<code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中 <code>A</code> 是有效括号字符串

  例如：<code>&quot;&quot;</code>，<code>&quot;()()&quot;</code>，和&nbsp;<code>&quot;()(()())&quot;</code>&nbsp;都是有效括号字符串，嵌套深度分别为 0，1，2，而&nbsp;<code>&quot;)(&quot;</code> 和&nbsp;<code>&quot;(()&quot;</code>&nbsp;都不是有效括号字符串。
  </pre>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
