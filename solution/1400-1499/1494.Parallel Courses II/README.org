* [[https://leetcode-cn.com/problems/parallel-courses-ii][1494. 并行课程
II]]
  :PROPERTIES:
  :CUSTOM_ID: 并行课程-ii
  :END:
[[./solution/1400-1499/1494.Parallel Courses II/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 dependencies 中， dependencies[i]
= [xi, yi] 
表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

在一个学期中，你 最多 可以同时上
k 门课，前提是这些课的先修课在之前的学期里已经上过了。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
  <strong>输出：</strong>3 
  <strong>解释：</strong>上图展示了题目输入的图。在第一个学期中，我们可以上课程 2 和课程 3 。然后第二个学期上课程 1 ，第三个学期上课程 4 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
  <strong>输出：</strong>4 
  <strong>解释：</strong>上图展示了题目输入的图。一个最优方案是：第一学期上课程 2 和 3，第二学期上课程 4 ，第三学期上课程 1 ，第四学期上课程 5 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 11, dependencies = [], k = 2
  <strong>输出：</strong>6
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 15

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= k <= n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= dependencies.length <= n * (n-1) / 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

dependencies[i].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= xi, yi <= n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

xi != yi

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

所有先修关系都是不同的，也就是说 dependencies[i] != dependencies[j] 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

题目输入的图是个有向无环图。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
