* [[https://leetcode-cn.com/problems/leftmost-column-with-at-least-a-one][1428.
至少有一个 1 的最左端列]]
  :PROPERTIES:
  :CUSTOM_ID: 至少有一个-1-的最左端列
  :END:
[[./solution/1400-1499/1428.Leftmost Column with at Least a One/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

（这是一个交互题）

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

我们称只包含元素 0 或 1 的矩阵为二进制矩阵。矩阵中每个单独的行都按非递减顺序排序。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

给定一个这样的二进制矩阵，返回至少包含一个 1 的最左端列的索引（从 0
开始）。如果这样的列不存在，返回 -1。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

您不能直接访问该二进制矩阵。你只可以通过 BinaryMatrix 接口来访问。

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

BinaryMatrix.get(row, col) 返回位于索引 (row, col) （从 0 开始）的元素。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

BinaryMatrix.dimensions() 返回含有 2 个元素的列表 [rows,
cols]，表示这是一个 rows * cols的矩阵。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

如果提交的答案调用 BinaryMatrix.get 超过 1000
次，则该答案会被判定为错误答案。提交任何试图规避判定机制的答案将会被取消资格。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

下列示例中， mat 为给定的二进制矩阵。您不能直接访问该矩阵。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入:</strong> mat = [[0,0],[1,1]]
  <strong>输出:</strong> 0
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入:</strong> mat = [[0,0],[0,1]]
  <strong>输出:</strong> 1
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入:</strong> mat = [[0,0],[0,0]]
  <strong>输出:</strong> -1</pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入:</strong> mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]
  <strong>输出:</strong> 1
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

rows == mat.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

cols == mat[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= rows, cols <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

mat[i][j] 只会是 0 或 1。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

mat[i] 已按非递减顺序排序。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
