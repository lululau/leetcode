* [[https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree][1489.
找到最小生成树里的关键边和伪关键边]]
  :PROPERTIES:
  :CUSTOM_ID: 找到最小生成树里的关键边和伪关键边
  :END:
[[./solution/1400-1499/1489.Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组
edges ，其中 edges[i] = [fromi, toi,
weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST)
是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你找到给定图中最小生成树的所有关键边和伪关键边。如果从图中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]]
  <strong>输出：</strong>[[0,1],[2,3,4,5]]
  <strong>解释：</strong>上图描述了给定图。
  下图是所有的最小生成树。
  <img alt="" src="https://cdn.jsdelivr.net/gh/doocs/leetcode@main/solution/1400-1499/1489.Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree/images/msts.png" style="height: 553px; width: 540px;">
  注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。
  边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2 ：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]]
  <strong>输出：</strong>[[],[0,1,2,3]]
  <strong>解释：</strong>可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= edges.length <= min(200, n * (n - 1) / 2)

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges[i].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= fromi < toi < n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= weighti <= 1000

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

所有 (fromi, toi) 数对都是互不相同的。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
