* [[https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree][1443.
收集树上所有苹果的最少时间]]
  :PROPERTIES:
  :CUSTOM_ID: 收集树上所有苹果的最少时间
  :END:
[[./solution/1400-1499/1443.Minimum Time to Collect All Apples in a Tree/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费
1 秒钟。你从 节点
0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

无向树的边由 edges 给出，其中 edges[i] = [fromi,
toi] ，表示有一条边连接 from 和 toi
。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] =
true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]
  <strong>输出：</strong>8 
  <strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]
  <strong>输出：</strong>6
  <strong>解释：</strong>上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]
  <strong>输出：</strong>0
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 10^5

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges.length == n-1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges[i].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= fromi, toi <= n-1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

fromi < toi

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

hasApple.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
