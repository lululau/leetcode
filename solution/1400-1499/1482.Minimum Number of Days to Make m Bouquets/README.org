* [[https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets][1482.
制作 m 束花所需的最少天数]]
  :PROPERTIES:
  :CUSTOM_ID: 制作-m-束花所需的最少天数
  :END:
[[./solution/1400-1499/1482.Minimum Number of Days to Make m Bouquets/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个整数数组 bloomDay，以及两个整数 m 和 k 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束
花中。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回
-1 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 1
  <strong>输出：</strong>3
  <strong>解释：</strong>让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
  现在需要制作 3 束花，每束只需要 1 朵。
  1 天后：[x, _, _, _, _]   // 只能制作 1 束花
  2 天后：[x, _, _, _, x]   // 只能制作 2 束花
  3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>bloomDay = [1,10,3,10,2], m = 3, k = 2
  <strong>输出：</strong>-1
  <strong>解释：</strong>要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3
  <strong>输出：</strong>12
  <strong>解释：</strong>要制作 2 束花，每束需要 3 朵。
  花园在 7 天后和 12 天后的情况如下：
  7 天后：[x, x, x, x, _, x, x]
  可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。
  12 天后：[x, x, x, x, x, x, x]
  显然，我们可以用不同的方式制作两束花。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>bloomDay = [1000000000,1000000000], m = 1, k = 1
  <strong>输出：</strong>1000000000
  <strong>解释：</strong>需要等 1000000000 天才能采到花来制作花束
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 5：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2
  <strong>输出：</strong>9
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

bloomDay.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 10^5

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= bloomDay[i] <= 10^9

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m <= 10^6

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= k <= n

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

利用二分查找快速定位

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def minDays(self, bloomDay: List[int], m: int, k: int) -> int:
          if m * k > len(bloomDay):
              return -1

          def check(day: int) -> bool:
              cnt, cur = 0, 0
              for bd in bloomDay:
                  cur = cur + 1 if bd <= day else 0
                  if cur == k:
                      cnt += 1
                      cur = 0
              return cnt >= m

          left, right = min(bloomDay), max(bloomDay)
          while left < right:
              mid = (left + right) // 2
              if check(mid):
                  right = mid
              else:
                  left = mid + 1
          return left
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int minDays(int[] bloomDay, int m, int k) {
          if (m * k > bloomDay.length) {
              return -1;
          }
          int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
          for (int bd : bloomDay) {
              min = Math.min(min, bd);
              max = Math.max(max, bd);
          }
          int left = min, right = max;
          while (left < right) {
              int mid = (left + right) >>> 1;
              if (check(bloomDay, m, k, mid)) {
                  right = mid;
              } else {
                  left = mid + 1;
              }
          }
          return left;
      }

      private boolean check(int[] bloomDay, int m, int k, int day) {
          int cnt = 0, cur = 0;
          for (int bd : bloomDay) {
              cur = bd <= day ? cur + 1 : 0;
              if (cur == k) {
                  cnt++;
                  cur = 0;
              }
          }
          return cnt >= m;
      }
  }
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
