* [[https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths][1697.
Checking Existence of Edge Length Limited Paths]]
  :PROPERTIES:
  :CUSTOM_ID: checking-existence-of-edge-length-limited-paths
  :END:
[[./solution/1600-1699/1697.Checking Existence of Edge Length Limited Paths/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

An undirected graph of n nodes is defined by edgeList, where edgeList[i]
= [ui, vi, disi] denotes an edge between nodes ui and vi with distance
disi. Note that there may be multiple edges between two nodes.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Given an array queries, where queries[j] = [pj, qj, limitj], your task
is to determine for each queries[j] whether there is a path between pj
and qj such that each edge on the path has a distance strictly less than
limitj .

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return a boolean array answer, where answer.length == queries.length and
the jth value of answer is true if there is a path for queries[j] is
true, and false otherwise.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]
  <strong>Output:</strong> [false,true]
  <strong>Explanation:</strong> The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.
  For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.
  For the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]
  <strong>Output:</strong> [true,false]
  <strong>Exaplanation:</strong> The above figure shows the given graph.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= edgeList.length, queries.length <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edgeList[i].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

queries[j].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= ui, vi, pj, qj <= n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

ui != vi

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

pj != qj

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= disi, limitj <= 109

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

There may be multiple edges between two nodes.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
