* [[https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities][1617.
统计子树中城市之间最大距离]]
  :PROPERTIES:
  :CUSTOM_ID: 统计子树中城市之间最大距离
  :END:
[[./solution/1600-1699/1617.Count Subtrees With Max Distance Between Cities/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你 n 个城市，编号为从 1
到 n 。同时给你一个大小为 n-1 的数组 edges ，其中 edges[i] = [ui,
vi] 表示城市 ui 和 vi 之间有一条双向边。题目保证任意城市之间只有唯一的一条路径。换句话说，所有城市形成了一棵 树 。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

一棵 子树 是城市的一个子集，且子集中任意城市之间可以通过子集中的其他城市和边到达。两个子树被认为不一样的条件是至少有一个城市在其中一棵子树中存在，但在另一棵子树中不存在。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

对于 d 从 1 到 n-1 ，请你找到城市间 最大距离 恰好为 d 的所有子树数目。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请你返回一个大小为 n-1 的数组，其中第 d 个元素（下标从 1 开始）是城市间
最大距离 恰好等于 d 的子树数目。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请注意，两个城市间距离定义为它们之间需要经过的边的数目。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <b>输入：</b>n = 4, edges = [[1,2],[2,3],[2,4]]
  <b>输出：</b>[3,4,0]
  <strong>解释：
  </strong>子树 {1,2}, {2,3} 和 {2,4} 最大距离都是 1 。
  子树 {1,2,3}, {1,2,4}, {2,3,4} 和 {1,2,3,4} 最大距离都为 2 。
  不存在城市间最大距离为 3 的子树。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <b>输入：</b>n = 2, edges = [[1,2]]
  <b>输出：</b>[1]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <b>输入：</b>n = 3, edges = [[1,2],[2,3]]
  <b>输出：</b>[2,1]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 15

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges.length == n-1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

edges[i].length == 2

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= ui, vi <= n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

题目保证 (ui, vi) 所表示的边互不相同。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
