* [[https://leetcode.com/problems/correct-a-binary-tree][1660. Correct a
Binary Tree]]
  :PROPERTIES:
  :CUSTOM_ID: correct-a-binary-tree
  :END:
[[./solution/1600-1699/1660.Correct a Binary Tree/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You have a binary tree with a small defect. There is exactly one invalid
node where its right child incorrectly points to another node at the
same depth but to the invalid node's right.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Given the root of the binary tree with this defect, root, return the
root of the binary tree after removing this invalid node and every node
underneath it (minus the node it incorrectly points to).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Custom testing:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The test input is read as 3 lines:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

TreeNode root

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int fromNode (not available to correctBinaryTree)

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

int toNode (not available to correctBinaryTree)

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

After the binary tree rooted at root is parsed, the TreeNode with value
of fromNode will have its right child pointer pointing to the TreeNode
with a value of toNode. Then, root is passed to correctBinaryTree.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>

  <strong>Input:</strong> root = [1,2,3], fromNode = 2, toNode = 3

  <strong>Output:</strong> [1,null,3]

  <strong>Explanation:</strong> The node with value 2 is invalid, so remove it.

  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>

  <strong>Input:</strong> root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4

  <strong>Output:</strong> [8,3,1,null,null,9,4,null,null,5,6]

  <strong>Explanation:</strong> The node with value 7 is invalid, so remove it and the node underneath it, node 2.

  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The number of nodes in the tree is in the range [3, 104].

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

-109 <= Node.val <= 109

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

All Node.val are unique.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

fromNode != toNode

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

fromNode and toNode will exist in the tree and will be on the same
depth.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

toNode is to the right of fromNode.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

fromNode.right is null in the initial tree from the test data.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
