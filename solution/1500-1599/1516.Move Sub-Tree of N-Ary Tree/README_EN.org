* [[https://leetcode.com/problems/move-sub-tree-of-n-ary-tree][1516.
Move Sub-Tree of N-Ary Tree]]
  :PROPERTIES:
  :CUSTOM_ID: move-sub-tree-of-n-ary-tree
  :END:
[[./solution/1500-1599/1516.Move Sub-Tree of N-Ary Tree/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

Given the root of an N-ary tree of unique values, and two nodes of the
tree p and q.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You should move the subtree of the node p to become a direct child of
node q. If p is already a direct child of q, don't change anything. Node
p must be the last child in the children list of node q.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return the root of the tree after adjusting it.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

There are 3 cases for nodes p and q:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

Node q is in the sub-tree of node p.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Node p is in the sub-tree of node q.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Neither node p is in the sub-tree of node q nor node q is in the
sub-tree of node p.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

In cases 2 and 3, you just need to move p (with its sub-tree) to be a
child of q, but in case 1 the tree may be disconnected, thus you need to
reconnect the tree again. Please read the examples carefully before
solving this problem.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Nary-Tree input serialization is represented in their level order
traversal, each group of children is separated by the null value (See
examples).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

For example, the above tree is serialized as
[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 4, q = 1
  <strong>Output:</strong> [1,null,2,3,4,null,5,null,6,null,7,8]
  <strong>Explanation:</strong> This example follows the second case as node p is in the sub-tree of node q. We move node p with its sub-tree to be a direct child of node q.
  Notice that node 4 is the last child of node 1.</pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 7, q = 4
  <strong>Output:</strong> [1,null,2,3,null,4,5,null,6,null,7,8]
  <strong>Explanation:</strong> Node 7 is already a direct child of node 4. We don&#39;t change anything.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 3, q = 8
  <strong>Output:</strong> [1,null,2,null,4,5,null,7,8,null,null,null,3,null,6]
  <strong>Explanation:</strong> This example follows case 3 because node p is not in the sub-tree of node q and vice-versa. We can move node 3 with its sub-tree and make it as node 8&#39;s child.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 4:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 2, q = 7
  <strong>Output:</strong> [1,null,7,3,null,2,null,6,null,4,5,null,null,8]
  <strong>Explanation:</strong> Node q is in the sub-tree of node p, so this is case 1.
  The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.
  Then we will see that the tree is disconnected, you need to reconnect node q to replace node p as shown.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 5:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> root = [1,null,2,3,null,4,5,null,6,null,7,8], p = 1, q = 2
  <strong>Output:</strong> [2,null,4,5,1,null,7,8,null,null,3,null,null,null,6]
  <strong>Explanation:</strong> Node q is in the sub-tree of node p, so this is case 1.
  The first step, we move node p (with all of its sub-tree except for node q) and add it as a child to node q.
  As node p was the root of the tree, node q replaces it and becomes the root of the tree.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The total number of nodes is between [2, 1000].

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Each node has a unique value.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

p != null

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

q != null

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

p and q are two different nodes (i.e. p != q).

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
