* [[https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters][1576.
替换所有的问号]]
  :PROPERTIES:
  :CUSTOM_ID: 替换所有的问号
  :END:
[[./solution/1500-1599/1576.Replace All %27s to Avoid Consecutive Repeating Characters/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?'
转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

注意：你 不能 修改非 '?' 字符。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;?zs&quot;
  <strong>输出：</strong>&quot;azs&quot;
  <strong>解释：</strong>该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;ubv?w&quot;
  <strong>输出：</strong>&quot;ubvaw&quot;
  <strong>解释：</strong>该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;j?qg??b&quot;
  <strong>输出：</strong>&quot;jaqgacb&quot;
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 4：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;??yw?ipkj?&quot;
  <strong>输出：</strong>&quot;acywaipkja&quot;
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

#+begin_html
  <p>
#+end_html

1 <= s.length <= 100

#+begin_html
  </p>
#+end_html

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

#+begin_html
  <p>
#+end_html

s 仅包含小写英文字母和 '?' 字符

#+begin_html
  </p>
#+end_html

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def modifyString(self, s: str) -> str:
          s = list(s)
          for i in range(len(s)):
              if s[i] == '?':
                  ahead = ' ' if i == 0 else s[i - 1]
                  behind = ' ' if i == len(s) - 1 else s[i + 1]
                  for c in string.ascii_lowercase:
                      if c != ahead and c != behind:
                          s[i] = c
                          break
          return "".join(s)
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public String modifyString(String s) {
          char[] chars = s.toCharArray();
          for (int i = 0; i < chars.length; i++) {
              if (chars[i] == '?') {
                  // 前面的字符
                  char ahead = i == 0 ? ' ' : chars[i - 1];
                  // 后面的字符
                  char behind = i == chars.length - 1 ? ' ' : chars[i + 1];
                  char temp = 'a';
                  while (temp == ahead || temp == behind) {
                      temp++;
                  }
                  chars[i] = temp;
              }
          }
          return new String(chars);
      }
  }
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func modifyString(s string) string {
      data := []byte(" " + s + " ")
      for i, c := range data {
          if c == byte('?') {
              ahead, behind := data[i-1], data[i+1]
              for t := byte('a'); t <= byte('z'); t++ {
                  if t != ahead && t != behind {
                      data[i] = t
                  }
              }
          }
      }
      return string(data[1 : len(data)-1])
  }
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
