* [[https://leetcode.com/problems/find-root-of-n-ary-tree][1506. Find
Root of N-Ary Tree]]
  :PROPERTIES:
  :CUSTOM_ID: find-root-of-n-ary-tree
  :END:
[[./solution/1500-1599/1506.Find Root of N-Ary Tree/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

You are given all the nodes of an N-ary tree as an array of Node
objects, where each node has a unique value.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Return the root of the N-ary tree.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Custom testing:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

An N-ary tree can be serialized as represented in its level order
traversal where each group of children is separated by the null value
(see examples).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

For example, the above tree is serialized as
[1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The testing will be done in the following way:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

The input data should be provided as a serialization of the tree.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The driver code will construct the tree from the serialized input data
and put each Node object into an array in an arbitrary order.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The driver code will pass the array to findRoot, and your function
should find and return the root Node object in the array.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The driver code will take the returned Node object and serialize it. If
the serialized value and the input data are the same, the test passes.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> tree = [1,null,3,2,4,null,5,6]
  <strong>Output:</strong> [1,null,3,2,4,null,5,6]
  <strong>Explanation:</strong> The tree from the input data is shown above.
  The driver code creates the tree and gives findRoot the Node objects in an arbitrary order.
  For example, the passed array could be [Node(5),Node(4),Node(3),Node(6),Node(2),Node(1)] or [Node(2),Node(6),Node(1),Node(3),Node(5),Node(4)].
  The findRoot function should return the root Node(1), and the driver code will serialize it and compare with the input data.
  The input data and serialized Node(1) are the same, so the test passes.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> tree = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
  <strong>Output:</strong> [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

The total number of nodes is between [1, 5 * 104].

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Each node has a unique value.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Follow up:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

Could you solve this problem in constant space complexity with a linear
time algorithm?

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
