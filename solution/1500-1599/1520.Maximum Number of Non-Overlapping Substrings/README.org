* [[https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings][1520.
最多的不重叠子字符串]]
  :PROPERTIES:
  :CUSTOM_ID: 最多的不重叠子字符串
  :END:
[[./solution/1500-1599/1520.Maximum Number of Non-Overlapping Substrings/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个只包含小写字母的字符串 s ，你需要找到
s 中最多数目的非空子字符串，满足如下条件：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j]
和 s[k..l] ，要么 j < k 要么 i > l 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果一个子字符串包含字符 char ，那么 s 中所有 char
字符都应该在这个子字符串中。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

请注意，你可以以 任意 顺序返回最优解的子字符串。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;adefaddaccc&quot;
  <strong>输出：</strong>[&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;]
  <strong>解释：</strong>下面为所有满足第二个条件的子字符串：
  [
  &nbsp; &quot;adefaddaccc&quot;
  &nbsp; &quot;adefadda&quot;,
  &nbsp; &quot;ef&quot;,
  &nbsp; &quot;e&quot;,
    &quot;f&quot;,
  &nbsp; &quot;ccc&quot;,
  ]
  如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 &quot;adefadda&quot; ，剩下子字符串中我们只可以选择 &quot;ccc&quot; ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 &quot;ef&quot; 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;] ，答案为 3 。不存在别的相同数目子字符串解。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>s = &quot;abbaccd&quot;
  <strong>输出：</strong>[&quot;d&quot;,&quot;bb&quot;,&quot;cc&quot;]
  <strong>解释：</strong>注意到解 [&quot;d&quot;,&quot;abba&quot;,&quot;cc&quot;] 答案也为 3 ，但它不是最优解，因为它的总长度更长。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= s.length <= 10^5

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

s 只包含小写英文字母。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
