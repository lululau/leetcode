* [[https://leetcode.com/problems/the-most-similar-path-in-a-graph][1548.
The Most Similar Path in a Graph]]
  :PROPERTIES:
  :CUSTOM_ID: the-most-similar-path-in-a-graph
  :END:
[[./solution/1500-1599/1548.The Most Similar Path in a Graph/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

We have n cities and m bi-directional roads where roads[i] = [ai, bi]
connects city ai with city bi. Each city has a name consisting of
exactly 3 upper-case English letters given in the string array names.
Starting at any city x, you can reach any city y where y != x (i.e. the
cities and the roads are forming an undirected connected graph).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You will be given a string array targetPath. You should find a path in
the graph of the same length and with the minimum edit distance to
targetPath.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

You need to return the order of the nodes in the path with the minimum
edit distance, The path should be of the same length of targetPath and
should be valid (i.e. there should be a direct road between ans[i] and
ans[i + 1]). If there are multiple answers return any one of them.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The edit distance is defined as follows:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Follow-up: If each node can be visited only once in the path, What
should you change in your solution?

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 5, roads = [[0,2],[0,3],[1,2],[1,3],[1,4],[2,4]], names = [&quot;ATL&quot;,&quot;PEK&quot;,&quot;LAX&quot;,&quot;DXB&quot;,&quot;HND&quot;], targetPath = [&quot;ATL&quot;,&quot;DXB&quot;,&quot;HND&quot;,&quot;LAX&quot;]
  <strong>Output:</strong> [0,2,4,2]
  <strong>Explanation:</strong> [0,2,4,2], [0,3,0,2] and [0,3,1,2] are accepted answers.
  [0,2,4,2] is equivalent to [&quot;ATL&quot;,&quot;LAX&quot;,&quot;HND&quot;,&quot;LAX&quot;] which has edit distance = 1 with targetPath.
  [0,3,0,2] is equivalent to [&quot;ATL&quot;,&quot;DXB&quot;,&quot;ATL&quot;,&quot;LAX&quot;] which has edit distance = 1 with targetPath.
  [0,3,1,2] is equivalent to [&quot;ATL&quot;,&quot;DXB&quot;,&quot;PEK&quot;,&quot;LAX&quot;] which has edit distance = 1 with targetPath.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 4, roads = [[1,0],[2,0],[3,0],[2,1],[3,1],[3,2]], names = [&quot;ATL&quot;,&quot;PEK&quot;,&quot;LAX&quot;,&quot;DXB&quot;], targetPath = [&quot;ABC&quot;,&quot;DEF&quot;,&quot;GHI&quot;,&quot;JKL&quot;,&quot;MNO&quot;,&quot;PQR&quot;,&quot;STU&quot;,&quot;VWX&quot;]
  <strong>Output:</strong> [0,1,0,1,0,1,0,1]
  <strong>Explanation:</strong> Any path in this graph has edit distance = 8 with targetPath.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 3:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 6, roads = [[0,1],[1,2],[2,3],[3,4],[4,5]], names = [&quot;ATL&quot;,&quot;PEK&quot;,&quot;LAX&quot;,&quot;ATL&quot;,&quot;DXB&quot;,&quot;HND&quot;], targetPath = [&quot;ATL&quot;,&quot;DXB&quot;,&quot;HND&quot;,&quot;DXB&quot;,&quot;ATL&quot;,&quot;LAX&quot;,&quot;PEK&quot;]
  <strong>Output:</strong> [3,4,5,4,3,2,1]
  <strong>Explanation:</strong> [3,4,5,4,3,2,1] is the only path with edit distance = 0 with targetPath.
  It&#39;s equivalent to [&quot;ATL&quot;,&quot;DXB&quot;,&quot;HND&quot;,&quot;DXB&quot;,&quot;ATL&quot;,&quot;LAX&quot;,&quot;PEK&quot;]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

m == roads.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n - 1 <= m <= (n * (n - 1) / 2)

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

0 <= ai, bi <= n - 1

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

ai != bi 

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

The graph is guaranteed to be connected and each pair of nodes may have
at most one direct road.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

names.length == n

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

names[i].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

names[i] consists of upper-case English letters.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

There can be two cities with the same name.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= targetPath.length <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

targetPath[i].length == 3

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

targetPath[i] consists of upper-case English letters.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
