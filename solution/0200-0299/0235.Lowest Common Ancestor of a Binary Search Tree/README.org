* [[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree][235.
二叉搜索树的最近公共祖先]]
  :PROPERTIES:
  :CUSTOM_ID: 二叉搜索树的最近公共祖先
  :END:
[[./solution/0200-0299/0235.Lowest Common Ancestor of a Binary Search Tree/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点
p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x
的深度尽可能大（一个节点也可以是它自己的祖先）。”

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  <strong>输出:</strong> 6 
  <strong>解释: </strong>节点 <code>2 </code>和节点 <code>8 </code>的最近公共祖先是 <code>6。</code>
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
  <strong>输出:</strong> 2
  <strong>解释: </strong>节点 <code>2</code> 和节点 <code>4</code> 的最近公共祖先是 <code>2</code>, 因为根据定义最近公共祖先节点可以为节点本身。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

所有节点的值都是唯一的。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

p、q 为不同节点且均存在于给定的二叉搜索树中。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

从上到下搜索，找到第一个值位于 =[p, q]=
之间的结点即可。既可以用迭代实现，也可以用递归实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

迭代：

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None

  class Solution:
      def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
          while root:
              if root.val < p.val and root.val < q.val:
                  root = root.right
              elif root.val > p.val and root.val > q.val:
                  root = root.left
              else:
                  return root
#+end_src

递归：

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None

  class Solution:
      def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
          if root is None:
              return None
          if root.val < p.val and root.val < q.val:
              return self.lowestCommonAncestor(root.right, p, q)
          if root.val > p.val and root.val > q.val:
              return self.lowestCommonAncestor(root.left, p, q)
          return root
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

迭代：

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */

  class Solution {
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          while (root != null) {
              if (root.val < p.val && root.val < q.val) root = root.right;
              else if (root.val > p.val && root.val > q.val) root = root.left;
              else return root;
          }
          return root;
      }
  }
#+end_src

递归：

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */

  class Solution {
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if (root == null) return null;
          if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
          if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
          return root;
      }
  }
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
迭代：

#+begin_example
  /**
   * Definition for a binary tree node.
   * type TreeNode struct {
   *     Val   int
   *     Left  *TreeNode
   *     Right *TreeNode
   * }
   */

  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
      for root != nil {
          // 如果 p、q 的值都小于 root，说明 p、q 肯定在 root 的左子树中；
          // 如果 p、q 都大于 root，说明肯定在 root 的右子树中；
          // 如果一个在左一个在右，则说明此时的 root 记为对应的最近公共祖先。
          if root.Val > p.Val && root.Val > q.Val {
              root = root.Left
          } else if root.Val < p.Val && root.Val < q.Val {
              root = root.Right
          } else {
              return root
          }
      }
      return nil
  }
#+end_example

递归：

#+begin_example
  /**
   * Definition for a binary tree node.
   * type TreeNode struct {
   *     Val   int
   *     Left  *TreeNode
   *     Right *TreeNode
   * }
   */

  func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
      if root == nil {
          return root
      }
      if root.Val < p.Val && root.Val < q.Val {
          return lowestCommonAncestor(root.Right, p, q)
      }
      if root.Val > p.Val && root.Val > q.Val {
          return lowestCommonAncestor(root.Left, p, q)
      }
      return root
  }
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
