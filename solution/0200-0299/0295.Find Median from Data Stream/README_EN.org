* [[https://leetcode.com/problems/find-median-from-data-stream][295.
Find Median from Data Stream]]
  :PROPERTIES:
  :CUSTOM_ID: find-median-from-data-stream
  :END:
[[./solution/0200-0299/0295.Find Median from Data Stream/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

The median is the middle value in an ordered integer list. If the size
of the list is even, there is no middle value and the median is the mean
of the two middle values.

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

For example, for arr = [2,3,4], the median is 3.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

Implement the MedianFinder class:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

MedianFinder() initializes the MedianFinder object.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

void addNum(int num) adds the integer num from the data stream to the
data structure.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

double findMedian() returns the median of all elements so far. Answers
within 10-5 of the actual answer will be accepted.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input</strong>
  [&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]
  [[], [1], [2], [], [3], []]
  <strong>Output</strong>
  [null, null, null, 1.5, null, 2.0]

  <strong>Explanation</strong>
  MedianFinder medianFinder = new MedianFinder();
  medianFinder.addNum(1);    // arr = [1]
  medianFinder.addNum(2);    // arr = [1, 2]
  medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
  medianFinder.addNum(3);    // arr[1, 2, 3]
  medianFinder.findMedian(); // return 2.0
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

-105 <= num <= 105

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

There will be at least one element in the data structure before calling
findMedian.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

At most 5 * 104 calls will be made to addNum and findMedian.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Follow up:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

If all integer numbers from the stream are in the range [0, 100], how
would you optimize your solution?

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

If 99% of all integer numbers from the stream are in the range [0, 100],
how would you optimize your solution?

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class MedianFinder:

      def __init__(self):
          """
          initialize your data structure here.
          """
          self.min_heap = []
          self.max_heap = []

      def addNum(self, num: int) -> None:
          heapq.heappush(self.min_heap, num)
          heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
          if len(self.max_heap) - len(self.min_heap) > 1:
              heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))

      def findMedian(self) -> float:
          if len(self.max_heap) > len(self.min_heap):
              return -self.max_heap[0]
          return (self.min_heap[0] - self.max_heap[0]) / 2


  # Your MedianFinder object will be instantiated and called as such:
  # obj = MedianFinder()
  # obj.addNum(num)
  # param_2 = obj.findMedian()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class MedianFinder {
      private PriorityQueue<Integer> minHeap;
      private PriorityQueue<Integer> maxHeap;

      /** initialize your data structure here. */
      public MedianFinder() {
          minHeap = new PriorityQueue<>();
          maxHeap = new PriorityQueue<>(Collections.reverseOrder());
      }

      public void addNum(int num) {
          minHeap.offer(num);
          maxHeap.offer(minHeap.poll());
          if (maxHeap.size() - minHeap.size() > 1) {
              minHeap.offer(maxHeap.poll());
          }
      }

      public double findMedian() {
          if (maxHeap.size() > minHeap.size()) {
              return maxHeap.peek();
          }
          return (minHeap.peek() + maxHeap.peek()) * 1.0 / 2;
      }
  }

  /**
   * Your MedianFinder object will be instantiated and called as such:
   * MedianFinder obj = new MedianFinder();
   * obj.addNum(num);
   * double param_2 = obj.findMedian();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
