* [[https://leetcode-cn.com/problems/find-median-from-data-stream][295.
数据流的中位数]]
  :PROPERTIES:
  :CUSTOM_ID: 数据流的中位数
  :END:
[[./solution/0200-0299/0295.Find Median from Data Stream/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

例如，

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

[2,3,4] 的中位数是 3

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

设计一个支持以下两种操作的数据结构：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

void addNum(int num) - 从数据流中添加一个整数到数据结构中。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

double findMedian() - 返回目前所有元素的中位数。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

示例：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>addNum(1)
  addNum(2)
  findMedian() -&gt; 1.5
  addNum(3) 
  findMedian() -&gt; 2</pre>
#+end_html

#+begin_html
  <p>
#+end_html

进阶:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

- 创建大根堆、小根堆，其中：大根堆存放较小的一半元素，小根堆存放较大的一半元素。
- 添加元素时，先放入小根堆，然后将小根堆对顶元素弹出并放入大根堆（使得大根堆个数多
  1）；若大小根堆元素个数差超过 1，则将大根堆元素弹出放入小根堆。
- 取中位数时，若大根堆元素较多，取大根堆堆顶，否则取两堆顶元素和的平均值。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class MedianFinder:

      def __init__(self):
          """
          initialize your data structure here.
          """
          self.min_heap = []
          self.max_heap = []

      def addNum(self, num: int) -> None:
          heapq.heappush(self.min_heap, num)
          heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))
          if len(self.max_heap) - len(self.min_heap) > 1:
              heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))

      def findMedian(self) -> float:
          if len(self.max_heap) > len(self.min_heap):
              return -self.max_heap[0]
          return (self.min_heap[0] - self.max_heap[0]) / 2


  # Your MedianFinder object will be instantiated and called as such:
  # obj = MedianFinder()
  # obj.addNum(num)
  # param_2 = obj.findMedian()
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class MedianFinder {
      private PriorityQueue<Integer> minHeap;
      private PriorityQueue<Integer> maxHeap;

      /** initialize your data structure here. */
      public MedianFinder() {
          minHeap = new PriorityQueue<>();
          maxHeap = new PriorityQueue<>(Collections.reverseOrder());
      }

      public void addNum(int num) {
          minHeap.offer(num);
          maxHeap.offer(minHeap.poll());
          if (maxHeap.size() - minHeap.size() > 1) {
              minHeap.offer(maxHeap.poll());
          }
      }

      public double findMedian() {
          if (maxHeap.size() > minHeap.size()) {
              return maxHeap.peek();
          }
          return (minHeap.peek() + maxHeap.peek()) * 1.0 / 2;
      }
  }

  /**
   * Your MedianFinder object will be instantiated and called as such:
   * MedianFinder obj = new MedianFinder();
   * obj.addNum(num);
   * double param_2 = obj.findMedian();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
