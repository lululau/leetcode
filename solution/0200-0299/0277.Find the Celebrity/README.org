* [[https://leetcode-cn.com/problems/find-the-celebrity][277. 搜寻名人]]
  :PROPERTIES:
  :CUSTOM_ID: 搜寻名人
  :END:
[[./solution/0200-0299/0277.Find the Celebrity/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

假设你是一个专业的狗仔，参加了一个 n 人派对，其中每个人被从 0 到 n -
1 标号。在这个派对人群当中可能存在一位 "名人"。所谓 "名人"
的定义是：其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

现在你想要确认这个 "名人"
是谁，或者确定这里没有 "名人"。而你唯一能做的就是问诸如
"A 你好呀，请问你认不认识 B呀？" 的问题，以确定 A 是否认识
B。你需要在（渐近意义上）尽可能少的问题内来确定这位 "名人"
是谁（或者确定这里没有 "名人"）。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

在本题中，你可以使用辅助函数 bool knows(a, b) 获取到 A 是否认识
B。请你来实现一个函数 int findCelebrity(n)。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

派对最多只会有一个 "名人" 参加。若 "名人"
存在，请返回他/她的编号；若 "名人" 不存在，请返回 -1。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入: </strong>graph = [
    [1,1,0],
    [0,1,0],
    [1,1,1]
  ]
  <strong>输出: </strong>1
  <strong>解释: </strong>有编号分别为 0、1 和 2 的三个人。graph[i][j] = 1 代表编号为 i 的人认识编号为 j 的人，而 graph[i][j] = 0 则代表编号为 i 的人不认识编号为 j 的人。“名人” 是编号 1 的人，因为 0 和 2 均认识他/她，但 1 不认识任何人。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入: </strong>graph = [
    [1,0,1],
    [1,1,0],
    [0,1,1]
  ]
  <strong>输出: </strong>-1
  <strong>解释: </strong>没有 “名人”
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

n == graph.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n == graph[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

2 <= n <= 100

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

graph[i][j] 是 0 或 1.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

graph[i][i] == 1

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

进阶：如果允许调用 API knows 的最大次数为 3 * n
，你可以设计一个不超过最大调用次数的解决方案吗？

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  </ol>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
