* [[https://leetcode.com/problems/game-of-life][289. Game of Life]]
  :PROPERTIES:
  :CUSTOM_ID: game-of-life
  :END:
[[./solution/0200-0299/0289.Game of Life/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

According to Wikipedia's article: "The Game of Life, also known simply
as Life, is a cellular automaton devised by the British mathematician
John Horton Conway in 1970."

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The board is made up of an m x n grid of cells, where each cell has an
initial state: live (represented by a 1) or dead (represented by a 0).
Each cell interacts with its eight neighbors (horizontal, vertical,
diagonal) using the following four rules (taken from the above Wikipedia
article):

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

Any live cell with fewer than two live neighbors dies as if caused by
under-population.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Any live cell with two or three live neighbors lives on to the next
generation.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Any live cell with more than three live neighbors dies, as if by
over-population.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

Any dead cell with exactly three live neighbors becomes a live cell, as
if by reproduction.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

The next state is created by applying the above rules simultaneously to
every cell in the current state, where births and deaths occur
simultaneously. Given the current state of the m x n grid board, return
the next state.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
  <strong>Output:</strong> [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> board = [[1,1],[1,0]]
  <strong>Output:</strong> [[1,1],[1,1]]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

m == board.length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

n == board[i].length

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= m, n <= 25

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

board[i][j] is 0 or 1.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Follow up:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

Could you solve it in-place? Remember that the board needs to be updated
simultaneously: You cannot update some cells first and then use their
updated values to update other cells.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

In this question, we represent the board using a 2D array. In principle,
the board is infinite, which would cause problems when the active area
encroaches upon the border of the array (i.e., live cells reach the
border). How would you address these problems?

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
