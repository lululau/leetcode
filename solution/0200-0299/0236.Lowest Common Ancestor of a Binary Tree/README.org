* [[https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree][236.
二叉树的最近公共祖先]]
  :PROPERTIES:
  :CUSTOM_ID: 二叉树的最近公共祖先
  :END:
[[./solution/0200-0299/0236.Lowest Common Ancestor of a Binary Tree/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

百度百科中最近公共祖先的定义为："对于有根树 T 的两个节点
p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x
的深度尽可能大（一个节点也可以是它自己的祖先）。"

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  <strong>输出：</strong>3
  <strong>解释：</strong>节点 <code>5 </code>和节点 <code>1 </code>的最近公共祖先是节点 <code>3 。</code>
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  <strong>输出：</strong>5
  <strong>解释：</strong>节点 <code>5 </code>和节点 <code>4 </code>的最近公共祖先是节点 <code>5 。</code>因为根据定义最近公共祖先节点可以为节点本身。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 3：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>输入：</strong>root = [1,2], p = 1, q = 2
  <strong>输出：</strong>1
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

提示：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

树中节点数目在范围 [2, 105] 内。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

-109 <= Node.val <= 109

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

所有 Node.val 互不相同 。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

p != q

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

p 和 q 均存在于给定的二叉树中。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

根据“*最近公共祖先*”的定义，若 root 是 p, q 的最近公共祖先
，则只可能为以下情况之一：

- 如果 p 和 q 分别是 root 的左右节点，那么 root
  就是我们要找的最近公共祖先；
- 如果 p 和 q 都是 root 的左节点，那么返回
  =lowestCommonAncestor(root.left, p, q)=；
- 如果 p 和 q 都是 root 的右节点，那么返回
  =lowestCommonAncestor(root.right, p, q)=。

*边界条件讨论*：

- 如果 root 为 null，则说明我们已经找到最底了，返回 null 表示没找到；
- 如果 root 与 p 相等或者与 q 相等，则返回 root；
- 如果左子树没找到，递归函数返回 null，证明 p 和 q 同在 root
  的右侧，那么最终的公共祖先就是右子树找到的结点；
- 如果右子树没找到，递归函数返回 null，证明 p 和 q 同在 root
  的左侧，那么最终的公共祖先就是左子树找到的结点。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None

  class Solution:
      def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
          if root is None or root == p or root == q:
              return root
          left = self.lowestCommonAncestor(root.left, p, q)
          right = self.lowestCommonAncestor(root.right, p, q)
          if left is None:
              return right
          if right is None:
              return left
          return root
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          if (root == null || root == p || root == q) return root;
          TreeNode left = lowestCommonAncestor(root.left, p, q);
          TreeNode right = lowestCommonAncestor(root.right, p, q);
          if (left == null) return right;
          if (right == null) return left;
          return root;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
    if (!root || root == p || root == q) return root;
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);
    if (!left) return right;
    if (!right) return left;
    return root;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
