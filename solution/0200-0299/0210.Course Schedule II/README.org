* [[https://leetcode-cn.com/problems/course-schedule-ii][210. 课程表
II]]
  :PROPERTIES:
  :CUSTOM_ID: 课程表-ii
  :END:
[[./solution/0200-0299/0210.Course Schedule II/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

现在你总共有 n 门课需要选，记为 0 到 n-1。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0
，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> 2, [[1,0]] 
  <strong>输出: </strong><code>[0,1]</code>
  <strong>解释:</strong>&nbsp;总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 <code>[0,1] 。</code></pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入:</strong> 4, [[1,0],[2,0],[3,1],[3,2]]
  <strong>输出: </strong><code>[0,1,2,3] or [0,2,1,3]</code>
  <strong>解释:</strong>&nbsp;总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
  &nbsp;    因此，一个正确的课程顺序是&nbsp;<code>[0,1,2,3]</code> 。另一个正确的排序是&nbsp;<code>[0,2,1,3]</code> 。
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

说明:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

你可以假定输入的先决条件中没有重复的边。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

提示:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

通过 DFS 进行拓扑排序 -
一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

#+begin_html
  <p>
#+end_html

拓扑排序也可以通过 BFS 完成。

#+begin_html
  </p>
#+end_html

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
