* [[https://leetcode-cn.com/problems/invert-binary-tree][226.
翻转二叉树]]
  :PROPERTIES:
  :CUSTOM_ID: 翻转二叉树
  :END:
[[./solution/0200-0299/0226.Invert Binary Tree/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

翻转一棵二叉树。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例：

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

输入：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>     4
     /   \
    2     7
   / \   / \
  1   3 6   9</pre>
#+end_html

#+begin_html
  <p>
#+end_html

输出：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>     4
     /   \
    7     2
   / \   / \
  9   6 3   1</pre>
#+end_html

#+begin_html
  <p>
#+end_html

备注: 这个问题是受到 Max Howell 的 原问题 启发的 ：

#+begin_html
  </p>
#+end_html

#+begin_html
  <blockquote>
#+end_html

谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

#+begin_html
  </blockquote>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None

  class Solution:
      def invertTree(self, root: TreeNode) -> TreeNode:
          if root is None:
              return None
          root.left, root.right = root.right, root.left
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {
      public TreeNode invertTree(TreeNode root) {
          if (root == null) return null;
          TreeNode t = root.left;
          root.left = root.right;
          root.right = t;
          invertTree(root.left);
          invertTree(root.right);
          return root;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   *     this.val = val;
   *     this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
  var invertTree = function (root) {
    if (!root) return null;
    [root.left, root.right] = [root.right, root.left];
    invertTree(root.left);
    invertTree(root.right);
    return root;
  };
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  /**
   * Definition for a binary tree node.
   * type TreeNode struct {
   *     Val int
   *     Left *TreeNode
   *     Right *TreeNode
   * }
   */
  func invertTree(root *TreeNode) *TreeNode {
      if (root == nil) {
          return nil
      }
      root.Left, root.Right = root.Right, root.Left
      invertTree(root.Left)
      invertTree(root.Right)
      return root
  }
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
