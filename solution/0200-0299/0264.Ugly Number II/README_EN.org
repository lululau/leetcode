* [[https://leetcode.com/problems/ugly-number-ii][264. Ugly Number II]]
  :PROPERTIES:
  :CUSTOM_ID: ugly-number-ii
  :END:
[[./solution/0200-0299/0264.Ugly Number II/README.org][中文文档]]

** Description
   :PROPERTIES:
   :CUSTOM_ID: description
   :END:

#+begin_html
  <p>
#+end_html

An ugly number is a positive integer whose prime factors are limited to
2, 3, and 5.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Given an integer n, return the nth ugly number.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Example 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 10
  <strong>Output:</strong> 12
  <strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

Example 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre>
  <strong>Input:</strong> n = 1
  <strong>Output:</strong> 1
  <strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Constraints:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

1 <= n <= 1690

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** Solutions
   :PROPERTIES:
   :CUSTOM_ID: solutions
   :END:

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:
#+begin_src python
  class Solution:
      def nthUglyNumber(self, n: int) -> int:
          dp = [1] * n
          p2 = p3 = p5 = 0
          for i in range(1, n):
              next2, next3, next5 = dp[p2] * 2, dp[p3] * 3, dp[p5] * 5
              dp[i] = min(next2, next3, next5)
              if dp[i] == next2:
                  p2 += 1
              if dp[i] == next3:
                  p3 += 1
              if dp[i] == next5:
                  p5 += 1
          return dp[n - 1]
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:
#+begin_src java
  class Solution {
      public int nthUglyNumber(int n) {
          int[] dp = new int[n];
          dp[0] = 1;
          int p2 = 0, p3 = 0, p5 = 0;
          for (int i = 1; i < n; ++i) {
              int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
              dp[i] = Math.min(next2, Math.min(next3, next5));
              if (dp[i] == next2) ++p2;
              if (dp[i] == next3) ++p3;
              if (dp[i] == next5) ++p5;
          }
          return dp[n - 1];
      }
  }
#+end_src

*** *C++*
    :PROPERTIES:
    :CUSTOM_ID: c
    :END:
#+begin_src cpp
  class Solution {
  public:
      int nthUglyNumber(int n) {
          vector<int> dp(n);
          dp[0] = 1;
          int p2 = 0, p3 = 0, p5 = 0;
          for (int i = 1; i < n; ++i) {
              int next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;
              dp[i] = min(next2, min(next3, next5));
              if (dp[i] == next2) ++p2;
              if (dp[i] == next3) ++p3;
              if (dp[i] == next5) ++p5;
          }
          return dp[n - 1];
      }
  };
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number} n
   * @return {number}
   */
  var nthUglyNumber = function (n) {
    let dp = [1];
    let p2 = 0,
      p3 = 0,
      p5 = 0;
    for (let i = 1; i < n; ++i) {
      const next2 = dp[p2] * 2,
        next3 = dp[p3] * 3,
        next5 = dp[p5] * 5;
      dp[i] = Math.min(next2, Math.min(next3, next5));
      if (dp[i] == next2) ++p2;
      if (dp[i] == next3) ++p3;
      if (dp[i] == next5) ++p5;
      dp.push(dp[i]);
    }
    return dp[n - 1];
  };
#+end_src

*** *Go*
    :PROPERTIES:
    :CUSTOM_ID: go
    :END:
#+begin_example
  func nthUglyNumber(n int) int {
      dp := make([]int, n)
      dp[0] = 1
      p2, p3, p5 := 0, 0, 0
      for i := 1; i < n; i++ {
          next2, next3, next5 := dp[p2]*2, dp[p3]*3, dp[p5]*5
          dp[i] = min(next2, min(next3, next5))
          if dp[i] == next2 {
              p2++
          }
          if dp[i] == next3 {
              p3++
          }
          if dp[i] == next5 {
              p5++
          }
      }
      return dp[n-1]
  }

  func min(a, b int) int {
      if a < b {
          return a
      }
      return b
  }
#+end_example

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
