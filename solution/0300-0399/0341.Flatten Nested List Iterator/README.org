* [[https://leetcode-cn.com/problems/flatten-nested-list-iterator][341.
扁平化嵌套列表迭代器]]
  :PROPERTIES:
  :CUSTOM_ID: 扁平化嵌套列表迭代器
  :END:
[[./solution/0300-0399/0341.Flatten Nested List Iterator/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入: </strong>[[1,1],2,[1,1]]
  <strong>输出: </strong>[1,1,2,1,1]
  <strong>解释: </strong>通过重复调用&nbsp;<em>next </em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,1,2,1,1]</code>。</pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入: </strong>[1,[4,[6]]]
  <strong>输出: </strong>[1,4,6]
  <strong>解释: </strong>通过重复调用&nbsp;<em>next&nbsp;</em>直到&nbsp;<em>hasNex</em>t 返回 false，<em>next&nbsp;</em>返回的元素的顺序应该是: <code>[1,4,6]</code>。
  </pre>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  # """
  # This is the interface that allows for creating nested lists.
  # You should not implement it, or speculate about its implementation
  # """
  #class NestedInteger:
  #    def isInteger(self) -> bool:
  #        """
  #        @return True if this NestedInteger holds a single integer, rather than a nested list.
  #        """
  #
  #    def getInteger(self) -> int:
  #        """
  #        @return the single integer that this NestedInteger holds, if it holds a single integer
  #        Return None if this NestedInteger holds a nested list
  #        """
  #
  #    def getList(self) -> [NestedInteger]:
  #        """
  #        @return the nested list that this NestedInteger holds, if it holds a nested list
  #        Return None if this NestedInteger holds a single integer
  #        """

  class NestedIterator:
      def __init__(self, nestedList: [NestedInteger]):
          def dfs(nestedList):
              for e in nestedList:
                  if e.isInteger():
                      self.vals.append(e.getInteger())
                  else:
                      dfs(e.getList())

          self.vals = []
          dfs(nestedList)
          self.cur = 0

      def next(self) -> int:
          res = self.vals[self.cur]
          self.cur += 1
          return res

      def hasNext(self) -> bool:
           return self.cur < len(self.vals)

  # Your NestedIterator object will be instantiated and called as such:
  # i, v = NestedIterator(nestedList), []
  # while i.hasNext(): v.append(i.next())
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  /**
   * // This is the interface that allows for creating nested lists.
   * // You should not implement it, or speculate about its implementation
   * public interface NestedInteger {
   *
   *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
   *     public boolean isInteger();
   *
   *     // @return the single integer that this NestedInteger holds, if it holds a single integer
   *     // Return null if this NestedInteger holds a nested list
   *     public Integer getInteger();
   *
   *     // @return the nested list that this NestedInteger holds, if it holds a nested list
   *     // Return null if this NestedInteger holds a single integer
   *     public List<NestedInteger> getList();
   * }
   */
  public class NestedIterator implements Iterator<Integer> {

      private List<Integer> vals;

      private Iterator<Integer> cur;

      public NestedIterator(List<NestedInteger> nestedList) {
          vals = new ArrayList<>();
          dfs(nestedList);
          cur = vals.iterator();
      }

      @Override
      public Integer next() {
          return cur.next();
      }

      @Override
      public boolean hasNext() {
          return cur.hasNext();
      }

      private void dfs(List<NestedInteger> nestedList) {
          for (NestedInteger e : nestedList) {
              if (e.isInteger()) {
                  vals.add(e.getInteger());
              } else {
                  dfs(e.getList());
              }
          }
      }
  }

  /**
   * Your NestedIterator object will be instantiated and called as such:
   * NestedIterator i = new NestedIterator(nestedList);
   * while (i.hasNext()) v[f()] = i.next();
   */
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
