* [[https://leetcode-cn.com/problems/intersection-of-two-arrays-ii][350.
两个数组的交集 II]]
  :PROPERTIES:
  :CUSTOM_ID: 两个数组的交集-ii
  :END:
[[./solution/0300-0399/0350.Intersection of Two Arrays II/README_EN.org][English
Version]]

** 题目描述
   :PROPERTIES:
   :CUSTOM_ID: 题目描述
   :END:

#+begin_html
  <!-- 这里写题目描述 -->
#+end_html

#+begin_html
  <p>
#+end_html

给定两个数组，编写一个函数来计算它们的交集。

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

示例 1：

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]
  <strong>输出：</strong>[2,2]
  </pre>
#+end_html

#+begin_html
  <p>
#+end_html

示例 2:

#+begin_html
  </p>
#+end_html

#+begin_html
  <pre><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]
  <strong>输出：</strong>[4,9]</pre>
#+end_html

#+begin_html
  <p>
#+end_html

 

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

说明：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

我们可以不考虑输出结果的顺序。

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

#+begin_html
  <p>
#+end_html

进阶：

#+begin_html
  </p>
#+end_html

#+begin_html
  <ul>
#+end_html

#+begin_html
  <li>
#+end_html

如果给定的数组已经排好序呢？你将如何优化你的算法？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果 nums1 的大小比 nums2 小很多，哪种方法更优？

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

#+begin_html
  </li>
#+end_html

#+begin_html
  </ul>
#+end_html

** 解法
   :PROPERTIES:
   :CUSTOM_ID: 解法
   :END:

#+begin_html
  <!-- 这里可写通用的实现逻辑 -->
#+end_html

"哈希表"实现。

#+begin_html
  <!-- tabs:start -->
#+end_html

*** *Python3*
    :PROPERTIES:
    :CUSTOM_ID: python3
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src python
  class Solution:
      def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
          counter = collections.Counter(nums1)
          res = []
          for num in nums2:
              if counter[num] > 0:
                  res.append(num)
                  counter[num] -= 1
          return res
#+end_src

*** *Java*
    :PROPERTIES:
    :CUSTOM_ID: java
    :END:

#+begin_html
  <!-- 这里可写当前语言的特殊实现逻辑 -->
#+end_html

#+begin_src java
  class Solution {
      public int[] intersect(int[] nums1, int[] nums2) {
          Map<Integer, Integer> counter = new HashMap<>();
          for (int num : nums1) {
              counter.put(num, counter.getOrDefault(num, 0) + 1);
          }
          List<Integer> intersection = new ArrayList<>();
          for (int num : nums2) {
              int val = counter.getOrDefault(num, 0);
              if (val > 0) {
                  intersection.add(num);
                  counter.put(num, val - 1);
              }
          }
          int i = 0;
          int[] res = new int[intersection.size()];
          for (int num : intersection) {
              res[i++] = num;
          }
          return res;
      }
  }
#+end_src

*** *JavaScript*
    :PROPERTIES:
    :CUSTOM_ID: javascript
    :END:
#+begin_src js
  /**
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number[]}
   */
  var intersect = function(nums1, nums2) {
      const counter = {};
      for (const num of nums1) {
          counter[num] = (counter[num] || 0) + 1;
      }
      let res = [];
      for (const num of nums2) {
          if (counter[num] > 0) {
              res.push(num);
              counter[num] -= 1;
          }
      }
      return res;
  };
#+end_src

*** *...*
    :PROPERTIES:
    :CUSTOM_ID: section
    :END:
#+begin_example
#+end_example

#+begin_html
  <!-- tabs:end -->
#+end_html
